<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>anti DDoS iptables | Shenlong616</title><meta name=keywords content="ddos,iptables,linux,firewall"><meta name=description content="There are different ways of building your own anti-DDoS rules for iptables. We will be discussing the most effective iptables DDoS protection methods in this comprehensive tutorial. This guide will teach you how to:
Select the best iptables table and chain to stop DDoS attacksTweak your kernel settings to mitigate the effects of DDoS attacksUse iptables to block most TCP-based DDoS attacksUse iptables SYNPROXY to block SYN floodsPlease note that this article is written for professionals who deal with Linux servers on a daily basis."><meta name=author content="scriptzteam"><link rel=canonical href=https://github.com/scriptzteam/anti-DDoS-iptables><meta name=google-site-verification content="AzXCkO0tq4MO96bDYSrwJRKKCYqk92c1N2Yere6jdxc"><meta name=msvalidate.01 content="24E5C745EF8D6815F97FBCACA22956C9"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://shenlong616.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://shenlong616.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://shenlong616.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://shenlong616.github.io/favicon/apple-touch-icon.png><link rel=mask-icon href=https://shenlong616.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>@import "https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"</style><script defer src="/../../assets/js/nprogress.min.js?v=0.2.0"></script>
<script defer src="/../../assets/js/scrollreveal.min.js?v=4.0.9"></script>
<script defer src="/../../assets/js/SmoothScroll.min.js?v=3.14.1"></script><meta property="og:title" content="anti DDoS iptables"><meta property="og:description" content="There are different ways of building your own anti-DDoS rules for iptables. We will be discussing the most effective iptables DDoS protection methods in this comprehensive tutorial. This guide will teach you how to:
Select the best iptables table and chain to stop DDoS attacksTweak your kernel settings to mitigate the effects of DDoS attacksUse iptables to block most TCP-based DDoS attacksUse iptables SYNPROXY to block SYN floodsPlease note that this article is written for professionals who deal with Linux servers on a daily basis."><meta property="og:type" content="article"><meta property="og:url" content="https://shenlong616.github.io/posts/github/scriptzteam/anti-ddos-iptables/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-09T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="anti DDoS iptables"><meta name=twitter:description content="There are different ways of building your own anti-DDoS rules for iptables. We will be discussing the most effective iptables DDoS protection methods in this comprehensive tutorial. This guide will teach you how to:
Select the best iptables table and chain to stop DDoS attacksTweak your kernel settings to mitigate the effects of DDoS attacksUse iptables to block most TCP-based DDoS attacksUse iptables SYNPROXY to block SYN floodsPlease note that this article is written for professionals who deal with Linux servers on a daily basis."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://shenlong616.github.io/posts/"},{"@type":"ListItem","position":2,"name":"GitHub","item":"https://shenlong616.github.io/posts/github/"},{"@type":"ListItem","position":3,"name":"anti DDoS iptables","item":"https://shenlong616.github.io/posts/github/scriptzteam/anti-ddos-iptables/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"anti DDoS iptables","name":"anti DDoS iptables","description":"There are different ways of building your own anti-DDoS rules for iptables. We will be discussing the most effective iptables DDoS protection methods in this comprehensive tutorial. This guide will teach you how to:\nSelect the best iptables table and chain to stop DDoS attacks\rTweak your kernel settings to mitigate the effects of DDoS attacks\rUse iptables to block most TCP-based DDoS attacks\rUse iptables SYNPROXY to block SYN floods\rPlease note that this article is written for professionals who deal with Linux servers on a daily basis.","keywords":["ddos","iptables","linux","firewall"],"articleBody":"There are different ways of building your own anti-DDoS rules for iptables. We will be discussing the most effective iptables DDoS protection methods in this comprehensive tutorial. This guide will teach you how to:\nSelect the best iptables table and chain to stop DDoS attacks\rTweak your kernel settings to mitigate the effects of DDoS attacks\rUse iptables to block most TCP-based DDoS attacks\rUse iptables SYNPROXY to block SYN floods\rPlease note that this article is written for professionals who deal with Linux servers on a daily basis. If you just want to protect your online application from DDoS attacks, you can use our remote protection, a VPS with DDoS protection or a DDoS protected bare metal server.\nWhile one can do a lot with iptables to block DDoS attacks, there isn’t a way around actual hardware firewalls (we recently reviewed RioRey DDoS mitigation hardware) to detect and stop large DDoS floods. However, it isn’t impossible to filter most bad traffic at line rate using iptables.\nWe’ll only cover protection from TCP-based attacks. Most UDP-based attacks are amplified reflection attacks that will exhaust the network interface card of any common server. The only mitigation approach that makes sense against these types of attacks is to block them at the edge or core network or even at the carrier already. If they are able to reach your server, there isn’t much you can do against those multi-Gbit/s attacks except to move to a DDoS protected network.\nanti-DDoS iptables What Is IPtables?\nnetfilter iptables (soon to be replaced by nftables) is a user-space command line utility to configure kernel packet filtering rules developed by netfilter. It’s the default firewall management utility on Linux systems - everyone working with Linux systems should be familiar with it or have at least heard of it.\niptables can be used to filter certain packets, block source or destination ports and IP addresses, forward packets via NAT and a lot of other things. Most commonly it’s used to block destination ports and source IP addresses. Why Your IPtables Anti-DDoS Rules Suck\nTo understand why your current iptables rules to prevent DDoS attacks suck, we first have to dig into how iptables works.\niptables is a command line tool used to set up and control the tables of IP packet filter rules. There are different tables for different purposes. IPtables Tables\nFilter: The filter table is the default and most commonly used table that rules go to if you don’t use the -t (–table) option.\nNat: This table is used for Network Address Translation (NAT). If a packet creates a new connection, the nat table gets checked for rules.\nMangle: The mangle table is used to modify or mark packets and their header information.\nRaw: This table’s purpose is mainly to exclude certain packets from connection tracking using the NOTRACK target.\nAs you can see there are four different tables on an average Linux system that doesn’t have non-standard kernel modules loaded. Each of these tables supports a different set of iptables chains. IPtables Chains PREROUTING: raw, nat, mangle\nApplies to packets that enter the network interface card (NIC)\rINPUT: filter, mangle\nApplies to packets destined to a local socket\rFORWARD: filter, mangle\nApplies to packets that are being routed through the server\rOUTPUT: raw, filter, nat, mangle\nApplies to packets that the server sends (locally generated)\rPOSTROUTING: nat, mangle\nApplies to packets that leave the server\rDepending on what kind of packets you want to block or modify, you select a certain iptables table and a chain that the selected table supports.\nOf course, we’re still missing an explanation of iptables targets (ACCEPT, DROP, REJECT, etc.), but we’re assuming that if you’re reading this article, you already know how to deal with iptables.\nWe’re going to explain why your iptables rules suck to stop DDoS and not teach you how to use iptables. Let’s get back to that.\nIf you want to block a DDoS attack with iptables, performance of the iptables rules is extremely important. Most TCP-based DDoS attack types use a high packet rate, meaning the sheer number of packets per second is what causes the server to go down. That’s why you want to make sure that you can process and block as many packets per second as possible.\nYou’ll find that most if not all guides on how to block DDoS attacks using iptables use the filter table and the INPUT chain for anti-DDoS rules. The issue with this approach is that the INPUT chain is only processed after the PREROUTING and FORWARD chains and therefore only applies if the packet doesn’t match any of these two chains.\nThis causes a delay in the filtering of the packet which consumes resources. In conclusion, to make our rules as effective as possible, we need to move our anti-DDoS rules as far up the chains as possible. The first chain that can apply to a packet is the PREROUTING chain, so ideally we’ll want to filter the bad packets in this chain already.\nHowever, the filter table doesn’t support the PREROUTING chain. To get around this problem, we can simply use the mangle table instead of the filter table for our anti-DDoS iptables rules. It supports most if not all rules that the filter table supports while also supporting all iptables chains.\nSo you want to know why your iptables DDoS protection rules suck? It’s because you use the filter table and the INPUT chain to block the bad packets! The best solution to dramatically increase the performance of your iptables rules and therefore the amount of (TCP) DDoS attack traffic they can filter is to use the mangle table and the PREROUTING chain! The Best Linux Kernel Settings to Mitigate DDoS\nAnother common mistake is that people don’t use optimized kernel settings to better mitigate the effects of DDoS attacks. Note that this guide focuses on CentOS 7 as the operating system of choice. CentOS 7 includes a recent version of iptables and support of the new SYNPROXY target.\nWe won’t cover every single kernel setting that you need to adjust in order to better mitigate DDoS with iptables. Instead, we provide a set of CentOS 7 kernel settings that we would use. Just put the below in your /etc/sysctl.conf file and apply the settings with sysctl -p. Anti-DDoS Kernel Settings (sysctl.conf)\nkernel.printk = 4 4 1 7\rkernel.panic = 10\rkernel.sysrq = 0\rkernel.shmmax = 4294967296\rkernel.shmall = 4194304\rkernel.core_uses_pid = 1\rkernel.msgmnb = 65536\rkernel.msgmax = 65536\rvm.swappiness = 20\rvm.dirty_ratio = 80\rvm.dirty_background_ratio = 5\rfs.file-max = 2097152\rnet.core.netdev_max_backlog = 262144\rnet.core.rmem_default = 31457280\rnet.core.rmem_max = 67108864\rnet.core.wmem_default = 31457280\rnet.core.wmem_max = 67108864\rnet.core.somaxconn = 65535\rnet.core.optmem_max = 25165824\rnet.ipv4.neigh.default.gc_thresh1 = 4096\rnet.ipv4.neigh.default.gc_thresh2 = 8192\rnet.ipv4.neigh.default.gc_thresh3 = 16384\rnet.ipv4.neigh.default.gc_interval = 5\rnet.ipv4.neigh.default.gc_stale_time = 120\rnet.netfilter.nf_conntrack_max = 10000000\rnet.netfilter.nf_conntrack_tcp_loose = 0\rnet.netfilter.nf_conntrack_tcp_timeout_established = 1800\rnet.netfilter.nf_conntrack_tcp_timeout_close = 10\rnet.netfilter.nf_conntrack_tcp_timeout_close_wait = 10\rnet.netfilter.nf_conntrack_tcp_timeout_fin_wait = 20\rnet.netfilter.nf_conntrack_tcp_timeout_last_ack = 20\rnet.netfilter.nf_conntrack_tcp_timeout_syn_recv = 20\rnet.netfilter.nf_conntrack_tcp_timeout_syn_sent = 20\rnet.netfilter.nf_conntrack_tcp_timeout_time_wait = 10\rnet.ipv4.tcp_slow_start_after_idle = 0\rnet.ipv4.ip_local_port_range = 1024 65000\rnet.ipv4.ip_no_pmtu_disc = 1\rnet.ipv4.route.flush = 1\rnet.ipv4.route.max_size = 8048576\rnet.ipv4.icmp_echo_ignore_broadcasts = 1\rnet.ipv4.icmp_ignore_bogus_error_responses = 1\rnet.ipv4.tcp_congestion_control = htcp\rnet.ipv4.tcp_mem = 65536 131072 262144\rnet.ipv4.udp_mem = 65536 131072 262144\rnet.ipv4.tcp_rmem = 4096 87380 33554432\rnet.ipv4.udp_rmem_min = 16384\rnet.ipv4.tcp_wmem = 4096 87380 33554432\rnet.ipv4.udp_wmem_min = 16384\rnet.ipv4.tcp_max_tw_buckets = 1440000\rnet.ipv4.tcp_tw_recycle = 0\rnet.ipv4.tcp_tw_reuse = 1\rnet.ipv4.tcp_max_orphans = 400000\rnet.ipv4.tcp_window_scaling = 1\rnet.ipv4.tcp_rfc1337 = 1\rnet.ipv4.tcp_syncookies = 1\rnet.ipv4.tcp_synack_retries = 1\rnet.ipv4.tcp_syn_retries = 2\rnet.ipv4.tcp_max_syn_backlog = 16384\rnet.ipv4.tcp_timestamps = 1\rnet.ipv4.tcp_sack = 1\rnet.ipv4.tcp_fack = 1\rnet.ipv4.tcp_ecn = 2\rnet.ipv4.tcp_fin_timeout = 10\rnet.ipv4.tcp_keepalive_time = 600\rnet.ipv4.tcp_keepalive_intvl = 60\rnet.ipv4.tcp_keepalive_probes = 10\rnet.ipv4.tcp_no_metrics_save = 1\rnet.ipv4.ip_forward = 0\rnet.ipv4.conf.all.accept_redirects = 0\rnet.ipv4.conf.all.send_redirects = 0\rnet.ipv4.conf.all.accept_source_route = 0\rnet.ipv4.conf.all.rp_filter = 1 These sysctl.conf settings help to maximize the performance of your server under DDoS as well as the effectiveness of the iptables rules that we’re going to provide in this guide. The Actual IPtables Anti-DDoS Rules\nConsidering you now know that you need to use the mangle table and the PREROUTING chain as well as optimized kernel settings to mitigate the effects of DDoS attacks, we’ll now move on to a couple of example rules to mitigate most TCP DDoS attacks.\nDDoS attacks are complex. There are many different types of DDoS and it’s close to impossible to maintain signature-based rules against all of them. But luckily there is something called connection tracking (nf_conntrack kernel module), which can help us to mitigate almost any TCP-based DDoS attack that doesn’t use SYN packets that seem legitimate. This includes all types of ACK and SYN-ACK DDoS attacks as well as DDoS attacks that use bogus TCP flags.\nWe’ll start with just five simple iptables rules that will already drop many TCP-based DDoS attacks. Block Invalid Packets\niptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP This rule blocks all packets that are not a SYN packet and don’t belong to an established TCP connection. Block New Packets That Are Not SYN\niptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP This blocks all packets that are new (don’t belong to an established connection) and don’t use the SYN flag. This rule is similar to the “Block Invalid Packets” one, but we found that it catches some packets that the other one doesn’t. Block Uncommon MSS Values\niptables -t mangle -A PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP The above iptables rule blocks new packets (only SYN packets can be new packets as per the two previous rules) that use a TCP MSS value that is not common. This helps to block dumb SYN floods. Block Packets With Bogus TCP Flags\niptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,RST FIN,RST -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,ACK FIN -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,URG URG -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,FIN FIN -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,PSH PSH -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL ALL -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL NONE -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP\riptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP The above ruleset blocks packets that use bogus TCP flags, ie. TCP flags that legitimate packets wouldn’t use. Block Packets From Private Subnets (Spoofing)\niptables -t mangle -A PREROUTING -s 224.0.0.0/3 -j DROP\riptables -t mangle -A PREROUTING -s 169.254.0.0/16 -j DROP\riptables -t mangle -A PREROUTING -s 172.16.0.0/12 -j DROP\riptables -t mangle -A PREROUTING -s 192.0.2.0/24 -j DROP\riptables -t mangle -A PREROUTING -s 192.168.0.0/16 -j DROP\riptables -t mangle -A PREROUTING -s 10.0.0.0/8 -j DROP\riptables -t mangle -A PREROUTING -s 0.0.0.0/8 -j DROP\riptables -t mangle -A PREROUTING -s 240.0.0.0/5 -j DROP\riptables -t mangle -A PREROUTING -s 127.0.0.0/8 ! -i lo -j DROP These rules block spoofed packets originating from private (local) subnets. On your public network interface you usually don’t want to receive packets from private source IPs. These rules assume that your loopback interface uses the 127.0.0.0/8 IP space.\nThese five sets of rules alone already block many TCP-based DDoS attacks at very high packet rates. With the kernel settings and rules mentioned above, you’ll be able to filter ACK and SYN-ACK attacks at line rate. Additional Rules\niptables -t mangle -A PREROUTING -p icmp -j DROP This drops all ICMP packets. ICMP is only used to ping a host to find out if it’s still alive. Because it’s usually not needed and only represents another vulnerability that attackers can exploit, we block all ICMP packets to mitigate Ping of Death (ping flood), ICMP flood and ICMP fragmentation flood.\niptables -A INPUT -p tcp -m connlimit --connlimit-above 80 -j REJECT --reject-with tcp-reset This iptables rule helps against connection attacks. It rejects connections from hosts that have more than 80 established connections. If you face any issues you should raise the limit as this could cause troubles with legitimate clients that establish a large number of TCP connections.\niptables -A INPUT -p tcp -m conntrack –ctstate NEW -m limit –limit 60/s –limit-burst 20 -j ACCEPT iptables -A INPUT -p tcp -m conntrack –ctstate NEW -j DROP\nLimits the new TCP connections that a client can establish per second. This can be useful against connection attacks, but not so much against SYN floods because the usually use an endless amount of different spoofed source IPs.\niptables -t mangle -A PREROUTING -f -j DROP This rule blocks fragmented packets. Normally you don’t need those and blocking fragments will mitigate UDP fragmentation flood. But most of the time UDP fragmentation floods use a high amount of bandwidth that is likely to exhaust the capacity of your network card, which makes this rule optional and probably not the most useful one.\niptables -A INPUT -p tcp --tcp-flags RST RST -m limit --limit 2/s --limit-burst 2 -j ACCEPT\riptables -A INPUT -p tcp --tcp-flags RST RST -j DROP This limits incoming TCP RST packets to mitigate TCP RST floods. Effectiveness of this rule is questionable. Mitigating SYN Floods With SYNPROXY\nSYNPROXY is a new target of iptables that has been added in Linux kernel version 3.12 and iptables 1.4.21. CentOS 7 backported the feature and it’s available in its 3.10 default kernel.\nThe purpose of SYNPROXY is to check whether the host that sent the SYN packet actually establishes a full TCP connection or just does nothing after it sent the SYN packet. If it does nothing, it discards the packet with minimal performance impact.\nWhile the iptables rules that we provided above already block most TCP-based attacks, the attack type that can still slip through them if sophisticated enough is a SYN flood. It’s important to note that the performance of the rules will always be better if we find a certain pattern or signature to block, such as packet length (-m length), TOS (-m tos), TTL (-m ttl) or strings and hex values (-m string and -m u32 for the more advanced users). But in some rare cases that’s not possible or at least not easy to achieve. So in these cases, you can make use of SYNPROXY.\nHere are iptables SYNPROXY rules that help mitigate SYN floods that bypass our other rules:\niptables -t raw -D PREROUTING -p tcp -m tcp --syn -j CT --notrack\riptables -D INPUT -p tcp -m tcp -m conntrack --ctstate INVALID,UNTRACKED -j SYNPROXY --sack-perm --timestamp --wscale 7 --mss 1460\riptables -D INPUT -m conntrack --ctstate INVALID -j DROP These rules apply to all ports. If you want to use SYNPROXY only on certain TCP ports that are active (recommended - also you should block all TCP ports that are not in use using the mangle table and PREROUTING chain), you can just add –dport 80 to each of the rules if you want to use SYNPROXY on port 80 only.\nTo verify that SYNPROXY is working, you can do watch -n1 cat /proc/net/stat/synproxy. If the values change when you establish a new TCP connection to the port you use SYNPROXY on, it works. The Complete IPtables Anti-DDoS Rules\nIf you don’t want to copy \u0026 paste each single rule we discussed in this article, you can use the below ruleset for basic DDoS protection of your Linux server.\n1: Drop invalid packets /sbin/iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP 2: Drop TCP packets that are new and are not SYN /sbin/iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP 3: Drop SYN packets with suspicious MSS value /sbin/iptables -t mangle -A PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP 4: Block packets with bogus TCP flags /sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,RST FIN,RST -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,ACK FIN -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,URG URG -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,FIN FIN -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,PSH PSH -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL ALL -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL NONE -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP\r/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP 5: Block spoofed packets /sbin/iptables -t mangle -A PREROUTING -s 224.0.0.0/3 -j DROP\r/sbin/iptables -t mangle -A PREROUTING -s 169.254.0.0/16 -j DROP\r/sbin/iptables -t mangle -A PREROUTING -s 172.16.0.0/12 -j DROP\r/sbin/iptables -t mangle -A PREROUTING -s 192.0.2.0/24 -j DROP\r/sbin/iptables -t mangle -A PREROUTING -s 192.168.0.0/16 -j DROP\r/sbin/iptables -t mangle -A PREROUTING -s 10.0.0.0/8 -j DROP\r/sbin/iptables -t mangle -A PREROUTING -s 0.0.0.0/8 -j DROP\r/sbin/iptables -t mangle -A PREROUTING -s 240.0.0.0/5 -j DROP\r/sbin/iptables -t mangle -A PREROUTING -s 127.0.0.0/8 ! -i lo -j DROP 6: Drop ICMP (you usually don’t need this protocol) /sbin/iptables -t mangle -A PREROUTING -p icmp -j DROP 7: Drop fragments in all chains /sbin/iptables -t mangle -A PREROUTING -f -j DROP 8: Limit connections per source IP /sbin/iptables -A INPUT -p tcp -m connlimit --connlimit-above 111 -j REJECT --reject-with tcp-reset 9: Limit RST packets /sbin/iptables -A INPUT -p tcp --tcp-flags RST RST -m limit --limit 2/s --limit-burst 2 -j ACCEPT\r/sbin/iptables -A INPUT -p tcp --tcp-flags RST RST -j DROP 10: Limit new TCP connections per second per source IP /sbin/iptables -A INPUT -p tcp -m conntrack --ctstate NEW -m limit --limit 60/s --limit-burst 20 -j ACCEPT\r/sbin/iptables -A INPUT -p tcp -m conntrack --ctstate NEW -j DROP 11: Use SYNPROXY on all ports (disables connection limiting rule) #/sbin/iptables -t raw -D PREROUTING -p tcp -m tcp --syn -j CT --notrack\r#/sbin/iptables -D INPUT -p tcp -m tcp -m conntrack --ctstate INVALID,UNTRACKED -j SYNPROXY --sack-perm --timestamp --wscale 7 --mss 1460\r#/sbin/iptables -D INPUT -m conntrack --ctstate INVALID -j DROP Bonus Rules\nHere are some more iptables rules that are useful to increase the overall security of a Linux server:\nSSH brute-force protection /sbin/iptables -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -m recent --set\r/sbin/iptables -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 10 -j DROP Protection against port scanning /sbin/iptables -N port-scanning\r/sbin/iptables -A port-scanning -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s --limit-burst 2 -j RETURN\r/sbin/iptables -A port-scanning -j DROP Conclusion This tutorial demonstrates some of the most powerful and effective methods to stop DDoS attacks using iptables. We’ve successfully mitigated DDoS attacks that peaked at multiple million packets per second using these iptables rules.\nEvery single guide on the same topic that we had researched provided inefficient methods to stop DDoS traffic or only a very limited number of iptables rules. If used correctly, iptables is an extremely powerful tool that’s able to block different types of DDoS attacks at line-rate of 1GigE NICs and close to line-rate of 10GigE NICs. Don’t underestimate the power of iptables!\n","wordCount":"3317","inLanguage":"en","datePublished":"2021-11-09T00:00:00Z","dateModified":"2021-11-09T00:00:00Z","author":{"@type":"Person","name":"scriptzteam"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://shenlong616.github.io/posts/github/scriptzteam/anti-ddos-iptables/"},"publisher":{"@type":"Person","name":"Shenlong616","logo":{"@type":"ImageObject","url":"https://shenlong616.github.io/favicon/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://shenlong616.github.io/ accesskey=h title="Shenlong616 (Alt + H)">Shenlong616</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://shenlong616.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://shenlong616.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://shenlong616.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://shenlong616.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://shenlong616.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://shenlong616.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://shenlong616.github.io/posts/github/>GitHub</a></div><h1 class=post-title>anti DDoS iptables</h1><div class=post-meta><span title='2021-11-09 00:00:00 +0000 UTC'>November 9, 2021</span>&nbsp;·&nbsp;3317 words&nbsp;·&nbsp;scriptzteam&nbsp;|&nbsp;<a href=https://github.com/Shenlong616/Shenlong616.github.io/tree/main/_dev/content/posts/github/scriptzteam/anti-DDoS-iptables.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
&nbsp;|&nbsp;<span>Originally published at&nbsp;<a href=https://github.com/scriptzteam/anti-DDoS-iptables title=https://github.com/scriptzteam/anti-DDoS-iptables target=_blank rel="noopener noreferrer">github.com</a></span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-drop-invalid-packets aria-label="1: Drop invalid packets">1: Drop invalid packets</a></li><li><a href=#2-drop-tcp-packets-that-are-new-and-are-not-syn aria-label="2: Drop TCP packets that are new and are not SYN">2: Drop TCP packets that are new and are not SYN</a></li><li><a href=#3-drop-syn-packets-with-suspicious-mss-value aria-label="3: Drop SYN packets with suspicious MSS value">3: Drop SYN packets with suspicious MSS value</a></li><li><a href=#4-block-packets-with-bogus-tcp-flags aria-label="4: Block packets with bogus TCP flags">4: Block packets with bogus TCP flags</a></li><li><a href=#5-block-spoofed-packets aria-label="5: Block spoofed packets">5: Block spoofed packets</a></li><li><a href=#6-drop-icmp-you-usually-dont-need-this-protocol aria-label="6: Drop ICMP (you usually don&amp;rsquo;t need this protocol)">6: Drop ICMP (you usually don&rsquo;t need this protocol)</a></li><li><a href=#7-drop-fragments-in-all-chains aria-label="7: Drop fragments in all chains">7: Drop fragments in all chains</a></li><li><a href=#8-limit-connections-per-source-ip aria-label="8: Limit connections per source IP">8: Limit connections per source IP</a></li><li><a href=#9-limit-rst-packets aria-label="9: Limit RST packets">9: Limit RST packets</a></li><li><a href=#10-limit-new-tcp-connections-per-second-per-source-ip aria-label="10: Limit new TCP connections per second per source IP">10: Limit new TCP connections per second per source IP</a></li><li><a href=#11-use-synproxy-on-all-ports-disables-connection-limiting-rule aria-label="11: Use SYNPROXY on all ports (disables connection limiting rule)">11: Use SYNPROXY on all ports (disables connection limiting rule)</a></li><li><a href=#ssh-brute-force-protection aria-label="SSH brute-force protection">SSH brute-force protection</a></li><li><a href=#protection-against-port-scanning aria-label="Protection against port scanning">Protection against port scanning</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>There are different ways of building your own anti-DDoS rules for iptables. We will be discussing the most effective iptables DDoS protection methods in this comprehensive tutorial.
This guide will teach you how to:</p><pre><code>Select the best iptables table and chain to stop DDoS attacks
Tweak your kernel settings to mitigate the effects of DDoS attacks
Use iptables to block most TCP-based DDoS attacks
Use iptables SYNPROXY to block SYN floods
</code></pre><p>Please note that this article is written for professionals who deal with Linux servers on a daily basis. If you just want to protect your online application from DDoS attacks, you can use our remote protection, a VPS with DDoS protection or a DDoS protected bare metal server.</p><p>While one can do a lot with iptables to block DDoS attacks, there isn&rsquo;t a way around actual hardware firewalls (we recently reviewed RioRey DDoS mitigation hardware) to detect and stop large DDoS floods. However, it isn&rsquo;t impossible to filter most bad traffic at line rate using iptables.</p><p>We&rsquo;ll only cover protection from TCP-based attacks. Most UDP-based attacks are amplified reflection attacks that will exhaust the network interface card of any common server. The only mitigation approach that makes sense against these types of attacks is to block them at the edge or core network or even at the carrier already. If they are able to reach your server, there isn&rsquo;t much you can do against those multi-Gbit/s attacks except to move to a DDoS protected network.</p><p>anti-DDoS iptables
What Is IPtables?</p><p>netfilter iptables (soon to be replaced by nftables) is a user-space command line utility to configure kernel packet filtering rules developed by netfilter. It&rsquo;s the default firewall management utility on Linux systems - everyone working with Linux systems should be familiar with it or have at least heard of it.</p><p>iptables can be used to filter certain packets, block source or destination ports and IP addresses, forward packets via NAT and a lot of other things. Most commonly it&rsquo;s used to block destination ports and source IP addresses.
Why Your IPtables Anti-DDoS Rules Suck</p><p>To understand why your current iptables rules to prevent DDoS attacks suck, we first have to dig into how iptables works.</p><p>iptables is a command line tool used to set up and control the tables of IP packet filter rules. There are different tables for different purposes.
IPtables Tables</p><p>Filter: The filter table is the default and most commonly used table that rules go to if you don&rsquo;t use the -t (&ndash;table) option.</p><p>Nat: This table is used for Network Address Translation (NAT). If a packet creates a new connection, the nat table gets checked for rules.</p><p>Mangle: The mangle table is used to modify or mark packets and their header information.</p><p>Raw: This table&rsquo;s purpose is mainly to exclude certain packets from connection tracking using the NOTRACK target.</p><p>As you can see there are four different tables on an average Linux system that doesn&rsquo;t have non-standard kernel modules loaded. Each of these tables supports a different set of iptables chains.
IPtables Chains
PREROUTING: raw, nat, mangle</p><pre><code>Applies to packets that enter the network interface card (NIC)
</code></pre><p>INPUT: filter, mangle</p><pre><code>Applies to packets destined to a local socket
</code></pre><p>FORWARD: filter, mangle</p><pre><code>Applies to packets that are being routed through the server
</code></pre><p>OUTPUT: raw, filter, nat, mangle</p><pre><code>Applies to packets that the server sends (locally generated)
</code></pre><p>POSTROUTING: nat, mangle</p><pre><code>Applies to packets that leave the server
</code></pre><p>Depending on what kind of packets you want to block or modify, you select a certain iptables table and a chain that the selected table supports.</p><p>Of course, we&rsquo;re still missing an explanation of iptables targets (ACCEPT, DROP, REJECT, etc.), but we&rsquo;re assuming that if you&rsquo;re reading this article, you already know how to deal with iptables.</p><p>We&rsquo;re going to explain why your iptables rules suck to stop DDoS and not teach you how to use iptables. Let&rsquo;s get back to that.</p><p>If you want to block a DDoS attack with iptables, performance of the iptables rules is extremely important. Most TCP-based DDoS attack types use a high packet rate, meaning the sheer number of packets per second is what causes the server to go down. That&rsquo;s why you want to make sure that you can process and block as many packets per second as possible.</p><p>You&rsquo;ll find that most if not all guides on how to block DDoS attacks using iptables use the filter table and the INPUT chain for anti-DDoS rules. The issue with this approach is that the INPUT chain is only processed after the PREROUTING and FORWARD chains and therefore only applies if the packet doesn&rsquo;t match any of these two chains.</p><p>This causes a delay in the filtering of the packet which consumes resources. In conclusion, to make our rules as effective as possible, we need to move our anti-DDoS rules as far up the chains as possible. The first chain that can apply to a packet is the PREROUTING chain, so ideally we&rsquo;ll want to filter the bad packets in this chain already.</p><p>However, the filter table doesn&rsquo;t support the PREROUTING chain. To get around this problem, we can simply use the mangle table instead of the filter table for our anti-DDoS iptables rules. It supports most if not all rules that the filter table supports while also supporting all iptables chains.</p><p>So you want to know why your iptables DDoS protection rules suck? It&rsquo;s because you use the filter table and the INPUT chain to block the bad packets! The best solution to dramatically increase the performance of your iptables rules and therefore the amount of (TCP) DDoS attack traffic they can filter is to use the mangle table and the PREROUTING chain!
The Best Linux Kernel Settings to Mitigate DDoS</p><p>Another common mistake is that people don&rsquo;t use optimized kernel settings to better mitigate the effects of DDoS attacks. Note that this guide focuses on CentOS 7 as the operating system of choice. CentOS 7 includes a recent version of iptables and support of the new SYNPROXY target.</p><p>We won&rsquo;t cover every single kernel setting that you need to adjust in order to better mitigate DDoS with iptables. Instead, we provide a set of CentOS 7 kernel settings that we would use. Just put the below in your /etc/sysctl.conf file and apply the settings with sysctl -p.
Anti-DDoS Kernel Settings (sysctl.conf)</p><pre tabindex=0><code>kernel.printk = 4 4 1 7
kernel.panic = 10
kernel.sysrq = 0
kernel.shmmax = 4294967296
kernel.shmall = 4194304
kernel.core_uses_pid = 1
kernel.msgmnb = 65536
kernel.msgmax = 65536
vm.swappiness = 20
vm.dirty_ratio = 80
vm.dirty_background_ratio = 5
fs.file-max = 2097152
net.core.netdev_max_backlog = 262144
net.core.rmem_default = 31457280
net.core.rmem_max = 67108864
net.core.wmem_default = 31457280
net.core.wmem_max = 67108864
net.core.somaxconn = 65535
net.core.optmem_max = 25165824
net.ipv4.neigh.default.gc_thresh1 = 4096
net.ipv4.neigh.default.gc_thresh2 = 8192
net.ipv4.neigh.default.gc_thresh3 = 16384
net.ipv4.neigh.default.gc_interval = 5
net.ipv4.neigh.default.gc_stale_time = 120
net.netfilter.nf_conntrack_max = 10000000
net.netfilter.nf_conntrack_tcp_loose = 0
net.netfilter.nf_conntrack_tcp_timeout_established = 1800
net.netfilter.nf_conntrack_tcp_timeout_close = 10
net.netfilter.nf_conntrack_tcp_timeout_close_wait = 10
net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 20
net.netfilter.nf_conntrack_tcp_timeout_last_ack = 20
net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 20
net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 20
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 10
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.ip_local_port_range = 1024 65000
net.ipv4.ip_no_pmtu_disc = 1
net.ipv4.route.flush = 1
net.ipv4.route.max_size = 8048576
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1
net.ipv4.tcp_congestion_control = htcp
net.ipv4.tcp_mem = 65536 131072 262144
net.ipv4.udp_mem = 65536 131072 262144
net.ipv4.tcp_rmem = 4096 87380 33554432
net.ipv4.udp_rmem_min = 16384
net.ipv4.tcp_wmem = 4096 87380 33554432
net.ipv4.udp_wmem_min = 16384
net.ipv4.tcp_max_tw_buckets = 1440000
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_max_orphans = 400000
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_rfc1337 = 1
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_synack_retries = 1
net.ipv4.tcp_syn_retries = 2
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_sack = 1
net.ipv4.tcp_fack = 1
net.ipv4.tcp_ecn = 2
net.ipv4.tcp_fin_timeout = 10
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 60
net.ipv4.tcp_keepalive_probes = 10
net.ipv4.tcp_no_metrics_save = 1
net.ipv4.ip_forward = 0
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.all.rp_filter = 1
</code></pre><p>These sysctl.conf settings help to maximize the performance of your server under DDoS as well as the effectiveness of the iptables rules that we&rsquo;re going to provide in this guide.
The Actual IPtables Anti-DDoS Rules</p><p>Considering you now know that you need to use the mangle table and the PREROUTING chain as well as optimized kernel settings to mitigate the effects of DDoS attacks, we&rsquo;ll now move on to a couple of example rules to mitigate most TCP DDoS attacks.</p><p>DDoS attacks are complex. There are many different types of DDoS and it&rsquo;s close to impossible to maintain signature-based rules against all of them. But luckily there is something called connection tracking (nf_conntrack kernel module), which can help us to mitigate almost any TCP-based DDoS attack that doesn&rsquo;t use SYN packets that seem legitimate. This includes all types of ACK and SYN-ACK DDoS attacks as well as DDoS attacks that use bogus TCP flags.</p><p>We&rsquo;ll start with just five simple iptables rules that will already drop many TCP-based DDoS attacks.
Block Invalid Packets</p><pre tabindex=0><code>iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP
</code></pre><p>This rule blocks all packets that are not a SYN packet and don&rsquo;t belong to an established TCP connection.
Block New Packets That Are Not SYN</p><pre tabindex=0><code>iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP
</code></pre><p>This blocks all packets that are new (don&rsquo;t belong to an established connection) and don&rsquo;t use the SYN flag. This rule is similar to the &ldquo;Block Invalid Packets&rdquo; one, but we found that it catches some packets that the other one doesn&rsquo;t.
Block Uncommon MSS Values</p><pre tabindex=0><code>iptables -t mangle -A PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP
</code></pre><p>The above iptables rule blocks new packets (only SYN packets can be new packets as per the two previous rules) that use a TCP MSS value that is not common. This helps to block dumb SYN floods.
Block Packets With Bogus TCP Flags</p><pre tabindex=0><code>iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,RST FIN,RST -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,ACK FIN -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,URG URG -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,FIN FIN -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,PSH PSH -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL ALL -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL NONE -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP
iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
</code></pre><p>The above ruleset blocks packets that use bogus TCP flags, ie. TCP flags that legitimate packets wouldn&rsquo;t use.
Block Packets From Private Subnets (Spoofing)</p><pre tabindex=0><code>iptables -t mangle -A PREROUTING -s 224.0.0.0/3 -j DROP
iptables -t mangle -A PREROUTING -s 169.254.0.0/16 -j DROP
iptables -t mangle -A PREROUTING -s 172.16.0.0/12 -j DROP
iptables -t mangle -A PREROUTING -s 192.0.2.0/24 -j DROP
iptables -t mangle -A PREROUTING -s 192.168.0.0/16 -j DROP
iptables -t mangle -A PREROUTING -s 10.0.0.0/8 -j DROP
iptables -t mangle -A PREROUTING -s 0.0.0.0/8 -j DROP
iptables -t mangle -A PREROUTING -s 240.0.0.0/5 -j DROP
iptables -t mangle -A PREROUTING -s 127.0.0.0/8 ! -i lo -j DROP
</code></pre><p>These rules block spoofed packets originating from private (local) subnets. On your public network interface you usually don&rsquo;t want to receive packets from private source IPs. These rules assume that your loopback interface uses the 127.0.0.0/8 IP space.</p><p>These five sets of rules alone already block many TCP-based DDoS attacks at very high packet rates. With the kernel settings and rules mentioned above, you&rsquo;ll be able to filter ACK and SYN-ACK attacks at line rate.
Additional Rules</p><pre tabindex=0><code>iptables -t mangle -A PREROUTING -p icmp -j DROP
</code></pre><p>This drops all ICMP packets. ICMP is only used to ping a host to find out if it&rsquo;s still alive. Because it&rsquo;s usually not needed and only represents another vulnerability that attackers can exploit, we block all ICMP packets to mitigate Ping of Death (ping flood), ICMP flood and ICMP fragmentation flood.</p><pre tabindex=0><code>iptables -A INPUT -p tcp -m connlimit --connlimit-above 80 -j REJECT --reject-with tcp-reset
</code></pre><p>This iptables rule helps against connection attacks. It rejects connections from hosts that have more than 80 established connections. If you face any issues you should raise the limit as this could cause troubles with legitimate clients that establish a large number of TCP connections.</p><p>iptables -A INPUT -p tcp -m conntrack &ndash;ctstate NEW -m limit &ndash;limit 60/s &ndash;limit-burst 20 -j ACCEPT
iptables -A INPUT -p tcp -m conntrack &ndash;ctstate NEW -j DROP</p><p>Limits the new TCP connections that a client can establish per second. This can be useful against connection attacks, but not so much against SYN floods because the usually use an endless amount of different spoofed source IPs.</p><pre tabindex=0><code>iptables -t mangle -A PREROUTING -f -j DROP
</code></pre><p>This rule blocks fragmented packets. Normally you don&rsquo;t need those and blocking fragments will mitigate UDP fragmentation flood. But most of the time UDP fragmentation floods use a high amount of bandwidth that is likely to exhaust the capacity of your network card, which makes this rule optional and probably not the most useful one.</p><pre tabindex=0><code>iptables -A INPUT -p tcp --tcp-flags RST RST -m limit --limit 2/s --limit-burst 2 -j ACCEPT
iptables -A INPUT -p tcp --tcp-flags RST RST -j DROP
</code></pre><p>This limits incoming TCP RST packets to mitigate TCP RST floods. Effectiveness of this rule is questionable.
Mitigating SYN Floods With SYNPROXY</p><p>SYNPROXY is a new target of iptables that has been added in Linux kernel version 3.12 and iptables 1.4.21. CentOS 7 backported the feature and it&rsquo;s available in its 3.10 default kernel.</p><p>The purpose of SYNPROXY is to check whether the host that sent the SYN packet actually establishes a full TCP connection or just does nothing after it sent the SYN packet. If it does nothing, it discards the packet with minimal performance impact.</p><p>While the iptables rules that we provided above already block most TCP-based attacks, the attack type that can still slip through them if sophisticated enough is a SYN flood. It&rsquo;s important to note that the performance of the rules will always be better if we find a certain pattern or signature to block, such as packet length (-m length), TOS (-m tos), TTL (-m ttl) or strings and hex values (-m string and -m u32 for the more advanced users). But in some rare cases that&rsquo;s not possible or at least not easy to achieve. So in these cases, you can make use of SYNPROXY.</p><p>Here are iptables SYNPROXY rules that help mitigate SYN floods that bypass our other rules:</p><pre tabindex=0><code>iptables -t raw -D PREROUTING -p tcp -m tcp --syn -j CT --notrack
iptables -D INPUT -p tcp -m tcp -m conntrack --ctstate INVALID,UNTRACKED -j SYNPROXY --sack-perm --timestamp --wscale 7 --mss 1460
iptables -D INPUT -m conntrack --ctstate INVALID -j DROP
</code></pre><p>These rules apply to all ports. If you want to use SYNPROXY only on certain TCP ports that are active (recommended - also you should block all TCP ports that are not in use using the mangle table and PREROUTING chain), you can just add &ndash;dport 80 to each of the rules if you want to use SYNPROXY on port 80 only.</p><p>To verify that SYNPROXY is working, you can do watch -n1 cat /proc/net/stat/synproxy. If the values change when you establish a new TCP connection to the port you use SYNPROXY on, it works.
The Complete IPtables Anti-DDoS Rules</p><p>If you don&rsquo;t want to copy & paste each single rule we discussed in this article, you can use the below ruleset for basic DDoS protection of your Linux server.</p><h3 id=1-drop-invalid-packets>1: Drop invalid packets<a hidden class=anchor aria-hidden=true href=#1-drop-invalid-packets>#</a></h3><pre tabindex=0><code>/sbin/iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP
</code></pre><h3 id=2-drop-tcp-packets-that-are-new-and-are-not-syn>2: Drop TCP packets that are new and are not SYN<a hidden class=anchor aria-hidden=true href=#2-drop-tcp-packets-that-are-new-and-are-not-syn>#</a></h3><pre tabindex=0><code>/sbin/iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP
</code></pre><h3 id=3-drop-syn-packets-with-suspicious-mss-value>3: Drop SYN packets with suspicious MSS value<a hidden class=anchor aria-hidden=true href=#3-drop-syn-packets-with-suspicious-mss-value>#</a></h3><pre tabindex=0><code>/sbin/iptables -t mangle -A PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss 536:65535 -j DROP
</code></pre><h3 id=4-block-packets-with-bogus-tcp-flags>4: Block packets with bogus TCP flags<a hidden class=anchor aria-hidden=true href=#4-block-packets-with-bogus-tcp-flags>#</a></h3><pre tabindex=0><code>/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,SYN FIN,SYN -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,RST FIN,RST -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags FIN,ACK FIN -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,URG URG -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,FIN FIN -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ACK,PSH PSH -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL ALL -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL NONE -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL FIN,PSH,URG -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,FIN,PSH,URG -j DROP
/sbin/iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
</code></pre><h3 id=5-block-spoofed-packets>5: Block spoofed packets<a hidden class=anchor aria-hidden=true href=#5-block-spoofed-packets>#</a></h3><pre tabindex=0><code>/sbin/iptables -t mangle -A PREROUTING -s 224.0.0.0/3 -j DROP
/sbin/iptables -t mangle -A PREROUTING -s 169.254.0.0/16 -j DROP
/sbin/iptables -t mangle -A PREROUTING -s 172.16.0.0/12 -j DROP
/sbin/iptables -t mangle -A PREROUTING -s 192.0.2.0/24 -j DROP
/sbin/iptables -t mangle -A PREROUTING -s 192.168.0.0/16 -j DROP
/sbin/iptables -t mangle -A PREROUTING -s 10.0.0.0/8 -j DROP
/sbin/iptables -t mangle -A PREROUTING -s 0.0.0.0/8 -j DROP
/sbin/iptables -t mangle -A PREROUTING -s 240.0.0.0/5 -j DROP
/sbin/iptables -t mangle -A PREROUTING -s 127.0.0.0/8 ! -i lo -j DROP
</code></pre><h3 id=6-drop-icmp-you-usually-dont-need-this-protocol>6: Drop ICMP (you usually don&rsquo;t need this protocol)<a hidden class=anchor aria-hidden=true href=#6-drop-icmp-you-usually-dont-need-this-protocol>#</a></h3><pre tabindex=0><code>/sbin/iptables -t mangle -A PREROUTING -p icmp -j DROP
</code></pre><h3 id=7-drop-fragments-in-all-chains>7: Drop fragments in all chains<a hidden class=anchor aria-hidden=true href=#7-drop-fragments-in-all-chains>#</a></h3><pre tabindex=0><code>/sbin/iptables -t mangle -A PREROUTING -f -j DROP
</code></pre><h3 id=8-limit-connections-per-source-ip>8: Limit connections per source IP<a hidden class=anchor aria-hidden=true href=#8-limit-connections-per-source-ip>#</a></h3><pre tabindex=0><code>/sbin/iptables -A INPUT -p tcp -m connlimit --connlimit-above 111 -j REJECT --reject-with tcp-reset
</code></pre><h3 id=9-limit-rst-packets>9: Limit RST packets<a hidden class=anchor aria-hidden=true href=#9-limit-rst-packets>#</a></h3><pre tabindex=0><code>/sbin/iptables -A INPUT -p tcp --tcp-flags RST RST -m limit --limit 2/s --limit-burst 2 -j ACCEPT
/sbin/iptables -A INPUT -p tcp --tcp-flags RST RST -j DROP
</code></pre><h3 id=10-limit-new-tcp-connections-per-second-per-source-ip>10: Limit new TCP connections per second per source IP<a hidden class=anchor aria-hidden=true href=#10-limit-new-tcp-connections-per-second-per-source-ip>#</a></h3><pre tabindex=0><code>/sbin/iptables -A INPUT -p tcp -m conntrack --ctstate NEW -m limit --limit 60/s --limit-burst 20 -j ACCEPT
/sbin/iptables -A INPUT -p tcp -m conntrack --ctstate NEW -j DROP
</code></pre><h3 id=11-use-synproxy-on-all-ports-disables-connection-limiting-rule>11: Use SYNPROXY on all ports (disables connection limiting rule)<a hidden class=anchor aria-hidden=true href=#11-use-synproxy-on-all-ports-disables-connection-limiting-rule>#</a></h3><pre tabindex=0><code>#/sbin/iptables -t raw -D PREROUTING -p tcp -m tcp --syn -j CT --notrack
#/sbin/iptables -D INPUT -p tcp -m tcp -m conntrack --ctstate INVALID,UNTRACKED -j SYNPROXY --sack-perm --timestamp --wscale 7 --mss 1460
#/sbin/iptables -D INPUT -m conntrack --ctstate INVALID -j DROP
</code></pre><p>Bonus Rules</p><p>Here are some more iptables rules that are useful to increase the overall security of a Linux server:</p><h3 id=ssh-brute-force-protection>SSH brute-force protection<a hidden class=anchor aria-hidden=true href=#ssh-brute-force-protection>#</a></h3><pre tabindex=0><code>/sbin/iptables -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -m recent --set
/sbin/iptables -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 10 -j DROP
</code></pre><h3 id=protection-against-port-scanning>Protection against port scanning<a hidden class=anchor aria-hidden=true href=#protection-against-port-scanning>#</a></h3><pre tabindex=0><code>/sbin/iptables -N port-scanning
/sbin/iptables -A port-scanning -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s --limit-burst 2 -j RETURN
/sbin/iptables -A port-scanning -j DROP
</code></pre><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>This tutorial demonstrates some of the most powerful and effective methods to stop DDoS attacks using iptables. We&rsquo;ve successfully mitigated DDoS attacks that peaked at multiple million packets per second using these iptables rules.</p><p>Every single guide on the same topic that we had researched provided inefficient methods to stop DDoS traffic or only a very limited number of iptables rules. If used correctly, iptables is an extremely powerful tool that&rsquo;s able to block different types of DDoS attacks at line-rate of 1GigE NICs and close to line-rate of 10GigE NICs. Don&rsquo;t underestimate the power of iptables!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://shenlong616.github.io/tags/ddos/>ddos</a></li><li><a href=https://shenlong616.github.io/tags/iptables/>iptables</a></li><li><a href=https://shenlong616.github.io/tags/linux/>linux</a></li><li><a href=https://shenlong616.github.io/tags/firewall/>firewall</a></li></ul><nav class=paginav><a class=prev href=https://shenlong616.github.io/posts/github/vinta/awesome-python/><span class=title>« Prev</span><br><span>Awesome Python</span></a>
<a class=next href=https://shenlong616.github.io/posts/undefined/hometown/><span class=title>Next »</span><br><span>Hometown</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://shenlong616.github.io/>Shenlong616</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>document.addEventListener("DOMContentLoaded",()=>{const e=e=>{NProgress.set(e),NProgress.done(!0)};if(e(.1),document.getElementsByTagName("input").length>0)for(const t of document.getElementsByTagName("input"))t.addEventListener("input",()=>{e(.1)});else void this;if(document.querySelectorAll(".copy-code, .top-link, #theme-toggle").length>0)for(const t of document.querySelectorAll(".copy-code, .top-link, #theme-toggle"))t.addEventListener("click",()=>{e(.1)});else void this;const t=e=>e[Math.floor(Math.random()*e.length)];if(ScrollReveal().noop)void this;else{const e={desktop:!0,mobile:!1,delay:0,duration:300,easing:"ease-out",reset:!0,distance:"6.16%",origin:"bottom",delay:0,beforeReveal:()=>{},afterReveal:()=>{}},n=()=>{const e=document.createElement("span"),n=document.createTextNode(`${Object.values(t([{Bengali:"নমস্কার!"},{boro:"खुलुम्बाइ!"},{Bulgarian:"Здравей!"},{Chinese:"你好!"},{Croat:"Zdravo!"},{Czech:"Ahoj!"},{Danish:"Hej!"},{Dutch:"Hallo!"},{English:"Hello!"},{Esperanto:"Saluton!"},{Estnisch:"Tere!"},{Farsi:"Salam!"},{Fidschi:"Bula!"},{Finnish:"Terve!"},{Flemish:"Hallo!"},{French:"Salut!"},{Greek:"Γειά!"},{Hawaiian:"Aloha!"},{Hebrew:"!שלום"},{Hindi:"नमस्ते!"},{Italian:"Ciao!"},{Japanese:"こんにちは!"},{Khmer:"Tchum-reaup Suw!"},{Korean:"안영하세요!"},{Lettish:"Čau!"},{Lithuanian:"Labas!"},{Malaiisch:"Hai!"},{Mongolian:"Сайн уу!"},{Norwegian:"Hei!"},{Polish:"Cześć!"},{Portuguese:"Olá!"},{Rumanian:"Salut!"},{Russian:"Привет!"},{Slovak:"Ahoj!"},{Spanish:"Hola!"},{Swedish:"Hej!"},{Swiss_German:"Hoi!"},{Tamil_Nadu:"வணக்கம்!"},{Thai:"สวัสดีคะ!"},{Turkish:"Merhaba!"},{Vietnamese:"Xin Chào!"}]))[0]}`);e.appendChild(n),Object.assign(e.style,{color:"var(--secondary)",fontSize:"0.6789em"}),document.querySelector(".logo").appendChild(e)};n(),ScrollReveal().reveal(document.querySelectorAll(".logo")[0].childNodes[0],{...e}),ScrollReveal().reveal(document.querySelectorAll(".logo")[0].childNodes[1],{...e,delay:e.delay+=25}),ScrollReveal().reveal(document.querySelectorAll(".logo")[0].childNodes[2],{...e,delay:e.delay+=25});for(const t of document.querySelectorAll("ul#menu")[0].childNodes)ScrollReveal().reveal(t,{...e,delay:e.delay+=25,origin:"left"})}async function n(){const e=await fetch("/../../assets/js/json/quotes.json?v=0.3.2"),n=await e.json();if(e.ok){const e=t(n);document.getElementsByName("quoteAuthor")[0].textContent=e.author,document.getElementsByName("quoteContent")[0].textContent=e.content}else void this}document.getElementsByName("quoteAuthor")[0]===void 0&&document.getElementsByName("quoteContent")[0]===void 0?void this:n()})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>