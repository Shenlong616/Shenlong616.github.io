[{"content":"This repository hosts my hardened version of sysctl.conf. This configuration file aims to provide better security for Linux systems and improves system performance whenever possible. For example, below are some of the features this configuration file provides.\nPrevents kernel pointers from being read Disables Ptrace for all programs Disallows core dumping by SUID/GUID programs Disables IPv4/IPv6 routing Enables BBR TCP congestion control Enables SYN cookies to mitigate SYN flooding attacks Enables IP reverse path filtering for source validation \u0026hellip; Please review the configuration file carefully before applying it. You are responsible for actions done to your system. If you need some guidance understanding what each of the settings is for, sysctl-explorer might come in handy. You may also consult Linux\u0026rsquo;s kernel documentation.\nAssumptions This configuration file is written with a few assumptions about your OS. You can still use this configuration as a template if your OS does not match these assumptions (e.g., set net.ipv4.ip_forward to 1 on a router). Making these assumptions helps us to develop a configuration file with the most number of optimizations enabled for common systems.\nSecurity is valued over performance and convenience The OS does not act as a router The OS is running on a 64-bit system The OS is on a network that is relatively stable (e.g., wired vs. LTE) No debugging features are required (e.g., no need for GDB/kdump) ICMP echo messages are not regarded as harmful Configuration Deployment Linux kernel configuration files are stored in the directory /etc/sysctl.d. Configurations in all files having a suffix of .conf will read by the procps (a.k.a. systemd-sysctl) service. Additionally, the procps service also loads configurations from the following directories.\n/run/sysctl.d /usr/local/lib/sysctl.d /usr/lib/sysctl.d /lib/sysctl.d Files are sorted and read by their file names in lexicographic order. Variables read later will overwrite variables read earlier. For example, configurations in 20-something.conf will be read before 99-sysctl.conf. If a variable exists in both files, values read from 20-something.conf will be overwritten by values read from 99-sysctl.conf.\n# in 20-something.conf\rnet.ipv4.ip_forward = 0\r# in 99-sysctl.conf\rnet.ipv4.ip_forward = 1\r# net.ipv4.ip_forward will be 1 Method 1: Deploy Definitively By default, on most Linux distributions, the /etc/sysctl.d/99-sysctl.conf file is a link to the /etc/sysctl.conf file. Therefore, you may write the variables into the /etc/sysctl.conf. However, since configuration files with a file name that starts with an alphabetical character sort later in the list than 99-sysctl.conf, the changes you make in the /etc/sysctl.conf might not be the final value loaded into the kernel. To make sure that your changes are loaded into the kernel, you would have to make sure that your configuration file\u0026rsquo;s name is lexicographically the last file in /etc/sysctl.d. The filename z-k4yt3x.conf will be used as an example in the code snippet below.\nThis deployment method is suitable for systems that do not expect to have their sysctl configurations updated from this repository anymore. Otherwise, the configuration file\u0026rsquo;s content has to be updated every time a new update form this repository is installed.\n# download the configuration file from GitHub using curl curl https://raw.githubusercontent.com/k4yt3x/sysctl/master/sysctl.conf -o ~/sysctl.conf # you may also download with wget or other methods if curl is not available wget https://raw.githubusercontent.com/k4yt3x/sysctl/master/sysctl.conf -O ~/sysctl.conf # move the configuration file into the sysctl configuration directory sudo mv ~/sysctl.conf /etc/sysctl.d/z-k4yt3x.conf # make sure the file has correct ownership and permissions sudo chown root:root /etc/sysctl.d/z-k4yt3x.conf sudo chmod 644 /etc/sysctl.d/z-k4yt3x.conf Method 2: Deploy as Template Alternatively, you can use this configuration file as a template. If you name the configuration file something akin to /etc/sysctl.d/98-k4yt3x.conf, you may overwrite values in this configuration file by giving them a new definition the /etc/sysctl.conf file.\nThe advantage of doing this is that you would not have to change this template file\u0026rsquo;s content every time it is updated in this repository. You can drop the template file in and make any modifications in /etc/sysctl.conf.\nThis method\u0026rsquo;s disadvantage is that values from this template might be overwritten by values in other configurations unknowingly. For example, a uhd-usrp2.conf exists on my system, and overwrites the value of net.core.rmem_max and net.core.wmem_max set in previous configuration files. Packages managers can install new configurations as you install a new package or update your system. Therefore, you will have to be careful that other files do not overwrite your variables.\n# download the configuration file from GitHub using curl curl https://raw.githubusercontent.com/k4yt3x/sysctl/master/sysctl.conf -o ~/sysctl.conf # you may also download with wget or other methods if curl is not available wget https://raw.githubusercontent.com/k4yt3x/sysctl/master/sysctl.conf -O ~/sysctl.conf # move the configuration file into the sysctl configuration directory sudo mv ~/sysctl.conf /etc/sysctl.d/98-k4yt3x.conf # make sure the file has correct ownership and permissions sudo chown root:root /etc/sysctl.d/98-k4yt3x.conf sudo chmod 644 /etc/sysctl.d/98-k4yt3x.conf Method 3: Custom Order (Personal Recommendation) To ensure that the configuration files are read in an order you prefer, you may also rename the files to your preference. For example, you can install this template to /etc/sysctl.d/y-k4yt3x.conf, then make a symbolic link from /etc/sysctl.d/z-sysctl.conf to /etc/sysctl.conf. This ensures that the two files are more likely to be read the last.\n# download the configuration file from GitHub using curl curl https://raw.githubusercontent.com/k4yt3x/sysctl/master/sysctl.conf -o ~/sysctl.conf # you may also download with wget or other methods if curl is not available wget https://raw.githubusercontent.com/k4yt3x/sysctl/master/sysctl.conf -O ~/sysctl.conf # move the configuration file into the sysctl configuration directory sudo mv ~/sysctl.conf /etc/sysctl.d/y-k4yt3x.conf # make sure the file has correct ownership and permissions sudo chown root:root /etc/sysctl.d/y-k4yt3x.conf sudo chmod 644 /etc/sysctl.d/y-k4yt3x.conf # point z-sysctl.conf to /etc/sysctl.conf sudo ln -s /etc/sysctl.conf /etc/sysctl.d/z-sysctl.conf Loading and Verifying the Changes For the changes to be effective, you will have to either reboot your machine or reload the configurations using one of the following commands.\n# instruct sysctl to load settings from the configuration file into the live kernel # this command allows you to see the variables as they are being loaded sudo sysctl --system # alternatively, you can restart the systemd-sysctl service on a system that uses systemd sudo systemctl restart systemd-sysctl # procps is an alias of systemd-sysctl # restarting either one of procps and systemd-sysctl would work sudo systemctl restart procps Afterwards, you may verify your changes by dumping all kernel variables. Replace your.config in the following command with the name of the variable you would like to check.\nsudo sysctl -a | grep \u0026#34;your.config\u0026#34; For example, the following command prints the value of kernel.kptr_restrict.\n$ sudo sysctl -a | grep \u0026#34;kernel.kptr_restrict\u0026#34; kernel.kptr_restrict = 2 Short URL for Downloading sysctl.conf For convenience, I have pointed the URL https://k4t.io/sysctl to the sysctl.conf file. You may therefore download the sysctl.conf file with the following command. However, be sure to check the file\u0026rsquo;s integrity after downloading it if you choose to download using this method.\ncurl -L k4t.io/sysctl -o sysctl.conf Backup sysctl.conf ","permalink":"https://shenlong616.github.io/posts/github/k4yt3xs-hardened-sysctl-configuration/","summary":"This repository hosts my hardened version of sysctl.conf. This configuration file aims to provide better security for Linux systems and improves system performance whenever possible. For example, below are some of the features this configuration file provides.\nPrevents kernel pointers from being read Disables Ptrace for all programs Disallows core dumping by SUID/GUID programs Disables IPv4/IPv6 routing Enables BBR TCP congestion control Enables SYN cookies to mitigate SYN flooding attacks Enables IP reverse path filtering for source validation \u0026hellip; Please review the configuration file carefully before applying it.","title":"K4YT3X's Hardened sysctl Configuration"},{"content":"\rDescription üòã This is a collection of JavaScript tips and tricks. you can refer to it and apply it to make your code more concise. But don\u0026rsquo;t overdo it, it can make your code difficult to read and maintain. Hope everyone contributes, thanks.\nArray 1. Generate an Array\rCreate an empty array of length n\nvar arr = new Array(3); // result: arr = [undefined, undefined, undefined] Create an empty array of length n \u0026amp; fill value x\nvar arr = [...Array(3).fill(1)]; var arr2 = [...Array(5).fill(1, 0, 3)]; /* result: arr = [1, 1, 1] arr2 = [1, 1, 1, undefined, undefined] */ Create an array containing 0...n\nvar arr = [...Array.keys(5)]; // result: arr = [0, 1, 2, 3, 4] Create an array containing 1...n\nvar arr = []; for (let i = 0; arr.push(++i) \u0026lt; 4; ); var arr2 = Array.from({ length: 4 }, (_, i) =\u0026gt; i + 1); var arr3 = Array.from({ length: 4 }, (_, i) =\u0026gt; i * 2); var arr4 = Array.from({ length: 4 }, () =\u0026gt; Math.random()); /* result: arr = [1, 2, 3, 4] arr2 = [1, 2, 3, 4] arr3 = [0, 2, 4, 6] arr4 = [0.211, 0.5123, 0.612, 0.8921] */ 2. Extract Unique Values of Array\rvar arr = [1, 2, 2, 3, 5, 5, 4]; var newArr = [...new Set(arr)]; // result: newArr = [1, 2, 3, 5, 4] 3. Shuffle Elements from Array\rvar arr = [1, 2, 3, 4, 5]; var newArr = arr.sort(() =\u0026gt; Math.random() - 0.5); // result: newArr = [3, 1, 2, 4, 5] 4. Flatten a Multidimensional Array\rvar arr = [1, [2, 3], [4, 5, 6], 7]; var newArr = [].concat(...arr); // result: [1, 2, 3, 4, 5, 6, 7] 5. Resize an Array\rThe length array isn\u0026rsquo;t a read only property.\nvar arr = [1, 2, 3, 4, 5]; arr.length = 2; var arr2 = [1, 2, 3, 4, 5]; arr2.length = 0; var arr3 = [1, 2, 3, 4, 5]; arr3.length = 7; /* result: arr = [1, 2] arr2 = [] arr3 = [1, 2, 3, 4, 5, undefined, undefined] */ 6. Random an Item in Array\rvar arr = [2, 4, 5]; var item = arr[Math.floor(Math.random() * arr.length)]; 7. Remove an Item from Array\rvar arr = [1, 2, 3]; // Not Recommended delete arr[1]; // arr = [1, undefined, 3], length = 3 // Recommended arr.splice(1, 1); // arr = [1, 3], length = 2 Object 1. Dynamic Property Name\rconst dynamic = \u0026#34;age\u0026#34;, dynamicValue = 18; var obj = { name: \u0026#34;Dyno\u0026#34;, [dynamic]: dynamicValue, }; // result: obj = { name: \u0026#39;Dyno\u0026#39;, age: 18 } 2. Clone an Object\rShallow copy (Not Recommended)\nUse the = operator to copy object 1 into object 2. These 2 objects point to the same memory area (reference). Therefore, if we change object 1, object 2 will also change.\nvar obj1 = { a: 1, b: 2 }; var obj2 = obj1; // obj2 = { a: 1, b: 2 } obj1.a = 3; // change value of a property console.log(obj1); // { a: 3, b: 2 } console.log(obj2); // { a: 3, b: 2 } =\u0026gt; property a of obj2 changed üôÇ‚ùó console.log(obj3); // { a: 3, b: 2 } =\u0026gt; property a of obj2 changed üôÇ‚ùó Deep copy\nWay 1: Use Spread operator {...} or Object.assign() to fix \u0026ldquo;Shallow copy\u0026rdquo;. Issue: Nested objects still have shallow copy problem.\nvar obj1 = { a: 1, b: 2, c: { nested: 3 } }; var obj2 = { ...obj1 }; // obj2 = { a: 1, b: 2, c: { nested: 3 } } var obj3 = Object.assign({}, obj1); // obj3 = { a: 1, b: 2, c: { nested: 3 } } obj1.b = 3; obj1.c.nested = 4; console.log(obj1); // { a: 1, b: 3, c: { nested: 4 } } console.log(obj2); // { a: 1, b: 2, c: { nested: 4 } } üôÇ console.log(obj3); // { a: 1, b: 2, c: { nested: 4 } } üôÇ Way 2 (Recommended): Use JSON.stringify() \u0026amp; JSON.parse() to solve the above problems.\nvar obj1 = { a: 1, b: 2, c: { nested: 3 } }; var obj2 = JSON.parse(JSON.stringify(obj1)); // obj2 = { a: 1, b: 2, c: { nested: 3 } } obj1.b = 3; obj1.c.nested = 4; console.log(obj1); // { a: 1, b: 3, c: { nested: 4 } } console.log(obj2); // { a: 1, b: 2, c: { nested: 3 } } üòâüòò Destructuring (ES6+) 1. With Array\rvar [a, b] = [1, 2]; // same: var a = 1, b = 2; var [a, b, c] = [1, 2, 3, 4, 5]; // same: var a = 1, b = 2, c = 3; var [a, , c] = [1, 2, 3, 4, 5]; // same: var a = 1, c = 3 // ignore values var [a, b, ...rest] = [1, 2, 3, 4, 5]; // same: var a = 1, b = 2, rest = [4, 5] // use \u0026#34;rest params ES6\u0026#34; var [a, b, c] = [1, 2]; // same: var a = 1, b = 2, c = undefined; var [a, b = 0, c = 0] = [1, 2]; // same: var a = 1, b = 2, c = 0; // declare and set default value var [a, b, [c, d], e] = [1, 2, [3, 4], 5]; // same: var a = 1, b = 2, c = 3, d = 4, e = 5 // nested array destructuring 2. With Object\rvar person = { name: \u0026#34;Dyno\u0026#34;, age: 18 }; var { name, age } = person; // same: var name = person.name, age = person.age; var { name = \u0026#34;Anonymous\u0026#34;, age = 1, address = \u0026#34;HCM city\u0026#34; } = person; // same: var name = person.name, age = person.age, address: \u0026#39;HCM city\u0026#39; // declare and set default value var { name: personName, age: personAge } = person; // same: var personName = person.name, personAge = person.age // decleare and change variable name console.log({ name, age }); // same: console.log({ name: name, age: age }) var person = { name: \u0026#34;Dyno\u0026#34;, age: 18, infor: { address: \u0026#34;HCM\u0026#34;, phone: \u0026#34;123\u0026#34; } }; var { name, age, infor: { address, phone }, } = person; // same: name = person.name, age = person.agem, address = person.infor.address, phone = person.infor.phone // nested object destructuring Operator 1. Optional chaining (?.)\r\u0026ldquo;The optional chaining operator ?. enables you to read the value of a property located deep within a chain of connected objects without having to check that each reference in the chain is valid.\u0026rdquo; MDN\nconst person = { name: \u0026#34;Dyno\u0026#34;, age: 18, sayHello: function () { console.log(\u0026#34;Hello\u0026#34;); }, }; // ‚ùó Wrong way console.log(person.infor.address); // ‚ùå Uncaught TypeError: Cannot read property \u0026#39;address\u0026#39; of undefined // ‚úÖ Right way (check condition) if (person.infor) console.log(person.infor.address); // Not log // ‚úÖ Right way (use ?.) console.log(person.infor?.address); // undefined // Optional chaining with function calls console.log(person.sayHello?.()); // Hello console.log(person.callPhone?.()); // undefined // A chain Optional chaining console.log(person.infor?.address?.province?.name); // undefined // syntax obj.val?.prop; obj.val?.[expr]; obj.arr?.[index]; obj.func?.(args); 2. Nullish coalescing operator (??)\r\u0026ldquo;The nullish coalescing operator ?? is a logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined, and otherwise returns its left-hand side operand.\u0026rdquo; MDN\nvar a = null ?? \u0026#34;Default\u0026#34;; // a = \u0026#39;Default\u0026#39; var a = false ?? \u0026#34;Default\u0026#34;; // a = false 3. Logical OR (||)\rvar a = 1, b = 2; if (a \u0026gt; 2 || b \u0026gt; 1) console.log(\u0026#34;Dyno\u0026#34;); // result: Dyno The OR operator || is a logical operator that returns its right-hand side operand when its left-hand side operand is falsy, and otherwise returns its left-hand side operand.\nvar a = null || \u0026#34;Default\u0026#34;; // a = \u0026#39;Default\u0026#39; var a = false || \u0026#34;Default\u0026#34;; // a = \u0026#39;Default\u0026#39; 4. Logical AND (\u0026\u0026)\rlet a = true, b = true, c = false; if (a \u0026amp;\u0026amp; b) console.log(\u0026#34;Hello\u0026#34;); // Hello (a, b = true) if (a \u0026amp;\u0026amp; c) console.log(\u0026#34;Dyno\u0026#34;); // not log (c = false) // other usage function sayHi() { console.log(\u0026#34;Hi\u0026#34;); } a \u0026amp;\u0026amp; sayHi(); // Hi c \u0026amp;\u0026amp; sayHi(); // false 5. Double tilde operator (~~)\rlet num = 2.6; console.log(~~num); // 2 = Math.floor(2) 6. Logical Assignment Operator ES12 (||=, ??=) a ||= b; // same a = a || b; a ??= b; // same a = a ?? b; 7. Numeric separator ES12 (_)\rconst n = 1_000_000_000; // same: n = 1000000000; Comparison 1. Use === instead of ==\rThe operator == (!=) will automatically cast if 2 variables are not of the same type, then compare. The === (!==) operator compares the value and the type =\u0026gt; === faster than ==.\n1 == \u0026#39;1\u0026#39; // true 1 === \u0026#39;1\u0026#39; // false 0 == false // true 0 === false // false \u0026#39;\u0026#39; == false // true \u0026#39;\u0026#39; === false // false [] == 0 // true [] === 0 // false 2. The difference between isNaN() and Number.isNaN() The isNaN() method (is Not a Number ?) use to check if a variable is a Number. The Number.isNaN() (is NaN ?) method use to check if a variable is NaN\nisNaN(\u0026#34;string\u0026#34;); // true, \u0026#39;string\u0026#39; is not Number isNaN([]); // true, [] is not Number isNaN(0 / 0); // true, 0/0 is not Number isNaN(1); // false, 1 is Number Number.isNaN(\u0026#34;string\u0026#34;); // false, \u0026#39;string\u0026#39; is not NaN Number.isNaN([]); // false, [] is not NaN Number.isNaN(0 / 0); // true, 0/0 is NaN Number.isNaN(NaN); // true Others 1. Swapping use Destructuring\rlet a = 1, b = 2; [a, b] = [b, a]; // result: a = 2, b = 1; 2. Create function that returns only 1 object\rconst fn = () =\u0026gt; ({ obj: 1 }); /* same: const fn = () =\u0026gt; { return { obj: 1 } } */ 3. Immediately Invoked Function Expression (IIFE)\rThe function will execute automatically when you create it.\n// Way 1: var res = ()(function(){ // do something... console.log(\u0026#34;Hello\u0026#34;); return true; })(); // result: Hello, res = true; // Way 2: var res = (() =\u0026gt; { console.log(\u0026#39;Hello\u0026#39;); return true; })(); // result: Hello, res = true; 4. typeof vs instanceof typeof: return a string that represents the primitive type of a variable.\ninstanceof: check in all the prototypes chain the constructor it returns true if it‚Äôs found and false if not.\nvar arr = [1, 2, 3]; console.log(typeof arr); // \u0026#34;object\u0026#34; console.log(arr instanceof Array); // true typeof 1; // \u0026#34;number\u0026#34; typeof NaN; // \u0026#34;number\u0026#34; typeof \u0026#34;str\u0026#34;; // \u0026#34;string\u0026#34; typeof true; // \u0026#34;boolean\u0026#34; typeof {}; // \u0026#34;object\u0026#34; typeof []; // \u0026#34;object\u0026#34; typeof null; // \u0026#34;object\u0026#34; typeof undefined; // \u0026#34;undefined\u0026#34; typeof function name() {}; // \u0026#34;function\u0026#34; 5. Falsy\rA Falsy value is a value that is considered false when encountered in a Boolean context . MDN\nComplete list of JavaScript falsy values false, 0, -0, 0n, \u0026quot;\u0026quot;, '', ``, NaN, null, undefined, document.all\nFalsy value bypass the if block. Ex:\nif (null) { } else { console.log(\u0026#34;Falsy\u0026#34;); } const a = undefined || \u0026#34;Falsy\u0026#34;; // result: Falsy, a = \u0026#34;Falsy\u0026#34; Filter out Falsy values\nconst arr = [1, \u0026#34;Dyno\u0026#34;, false, 0, true, NaN, 2000]; var filteredArr = arr.filter(Boolean); // result: filteredArr = [1, \u0026#34;Dyno\u0026#34;, true, 2000] 6. Template string `${}`\rconst name = \u0026#34;Dyno\u0026#34;; const hello1 = \u0026#34;Hello \u0026#34; + name + \u0026#34;, how are you?\u0026#34;; const hello2 = `Hello ${name}, how are you?`; // template string. 7. Rounding number to n decimal place\rvar num = 25.0420001; console.log(typeof num); // \u0026#34;number\u0026#34; num = num.toFixed(2); // num = \u0026#34;25.04\u0026#34; console.log(typeof num); // ‚ùó \u0026#34;string\u0026#34; 8. Check variable - convert a variable to Boolean (!! operator)\rconsole.log(!!null); // false console.log(!!undefined); // false console.log(!!1); // true ","permalink":"https://shenlong616.github.io/posts/github/javascript-tips-tricks-by-tuannguyen2504/","summary":"Description üòã This is a collection of JavaScript tips and tricks. you can refer to it and apply it to make your code more concise. But don\u0026rsquo;t overdo it, it can make your code difficult to read and maintain. Hope everyone contributes, thanks.\nArray 1. Generate an Array\rCreate an empty array of length n\nvar arr = new Array(3); // result: arr = [undefined, undefined, undefined] Create an empty array of length n \u0026amp; fill value x","title":"JavaScript tips \u0026 tricks by TuanNguyen2504"},{"content":"Python 3 tricks Disclaimer: This list is meant as a comprehension of cool tips and tricks I found on the internet. If you would like to contribute, or notice any mistakes or typos, please contact me or upload a pull request. If you think any material here can be considered personal property let me know and I will take it down.\n1. Looping over a range of numbers Using range() is better than using a list (ex. [1, 2, 3]), because the list takes up memory space, whereas the range() function generates values on demand, thus taking a fixed amount of memory whatever the size of the elements is:\nfor i in range(10): print(i**2) takes the same memory space as:\nfor i in range(100000): print(i**2) Note: This function used to create a list in python2, and xrange() used to do what range() currently does, but it got changed, so range() in python3 is xrange() in python2.\n2. Looping backwards Use the function reversed():\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] for lang in reversed(langs): print(lang) # prints rust, kotlin, c++, java, python, c 3. Looping over a collection and indices Use the function enumerate():\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] for i,lang in enumerate(langs): print(f\u0026#39;{i} --\u0026gt; {lang}\u0026#39;) # prints # 0 --\u0026gt; c # 1 --\u0026gt; python # 2 --\u0026gt; java # 3 --\u0026gt; c++ # 4 --\u0026gt; kotlin # 5 --\u0026gt; rust 4. Looping over two collections Use the function zip(). It returns tuples of the elements until one of the iterables is exahusted:\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] numbers = [1, 2, 3] for number, lang in zip(numbers, langs): print(f\u0026#39;{number} --\u0026gt; {lang}\u0026#39;) # prints # 1 --\u0026gt; c # 2 --\u0026gt; python # 3 --\u0026gt; java Note: It takes any number of iterables and \u0026ldquo;zips\u0026rdquo; them into tuples.\nNote 2: It\u0026rsquo;s important to note that it generates tuples on demand, so it reuses memory space (it used to create a third list in python2, and izip() used to do what zip() does now in python3).\n5. Looping in sorted order Use the function sorted() or the method sort() of iterables.\nBy default, it sorts the iterable in ascending order:\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] for lang in sorted(langs): print(lang) # or langs.sort() print(*langs) # prints c c++ java kotlin python rust The second method sorts the iterable IN-PLACE, whilst the first returns a different iterable.\nBoth the functions can take 2 extra parameters which can specify a comparison function and if the iterable should be reversed:\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] for lang in sorted(langs, key=len, reverse=True): print(lang) # or langs.sort(key=len, reverse=True) print(*langs) # prints kotlin python java rust c++ c # notice that kotlin and python might be interchanged because they have the same size, same java and rust 6. Partial functions A partial function is a function who has some parameters \u0026ldquo;frozen\u0026rdquo;, in the sense that they are preset. The other parameters must be given when the partial function is called:\nfrom functools import partial def func(x, y, z): return x + 2*y + 3*z my_func = partial(func, 2, 3) # assign (preset) 2 to x, 3 to y my_func(3) # equivalent to func(2, 3, 3) # prints 17 my_func(4) # equivalent to func(2, 3, 4) # prints 20 7. Fastest way to format multiple strings Going from fastest to slowest, they are:\nf\u0026#39;{s} {t}\u0026#39; # fastest s + \u0026#39; \u0026#39; + t \u0026#39; \u0026#39;.join((s, t)) \u0026#39;%s %s\u0026#39; % (s, t) \u0026#39;{} {}\u0026#39;.format(s, t) Template(\u0026#39;$s $t\u0026#39;).substitute(s=s, t=t) # slowest Note: f-strings were added in Python 3.6.\n8. Iterating until a sentinel value This method has 2 forms:\niter(iterable) - this form simply returns an iterator from the iterable. You can call next() on the iterator and iterate through the iterable. langs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] ir = iter(langs) print(next(ir)) # prints c print(next(ir)) # prints python iter(callable, sentinel) - this form executes the function callable until it returns sentinel value. def func(langs = []): langs.append(\u0026#39;c\u0026#39;) return len(langs) ir = iter(func, 5) next(ir) # prints 1 next(ir) # prints 2 next(ir) # prints 3 next(ir) # prints 4 next(ir) # raise StopIteration Read 80 characters from file f into line and append to text until f.read() returns '':\ntext = list() for line in iter(partial(f.read, 80), \u0026#39;\u0026#39;): text.append(line) 9. For else in Python Search a certain value in an iterable and do something if it is not there:\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] for lang in langs: if lang == \u0026#39;scala\u0026#39;: print(\u0026#39;We found Scala!\u0026#39;) break else: print(\u0026#39;Scala is not in the list...\u0026#39;) Note: Careful if you ever come back to this kind of code. Don\u0026rsquo;t indent the else statement by accident!!!\n10. Looping over dictionary keys d = { \u0026#39;foo\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;bar\u0026#39;: \u0026#39;java\u0026#39;, \u0026#39;baz\u0026#39;: \u0026#39;rust\u0026#39; } # cannot mutate dictionary here for k in d: print(k) # free to mutate the keys and values for k in list(d.keys()): if k == \u0026#39;foo\u0026#39;: del d[k] Note: d.keys() used to make a list copy of the keys, so there was no problem iterating and mutating the original dictionary at the same time. In modern Python3, d.keys() returns an iterable and can no longer be used to iterate and mutate a dictionary at the same time. To go around this, just wrap the method into a list as in the example.\nNote 2: There is an \u0026lsquo;alternative\u0026rsquo; to this, but it has worse performance and memory usage:\nd = { \u0026#39;foo\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;bar\u0026#39;: \u0026#39;java\u0026#39;, \u0026#39;baz\u0026#39;: \u0026#39;rust\u0026#39; } # Don\u0026#39;t do this, performance is bad as it copies every element in a dictionary and can be really bad for really big dictionaries s = {k: v for k, v in d.items() if k != \u0026#39;foo\u0026#39;} 11. Looping over dictionary keys and values d = { \u0026#39;foo\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;bar\u0026#39;: \u0026#39;java\u0026#39;, \u0026#39;baz\u0026#39;: \u0026#39;rust\u0026#39; } for k, v in d.items(): print(f\u0026#39;{k} --\u0026gt; {v}\u0026#39;) The items() method returns and iterator, so it uses the same amount of memory no matter how big the dictionary is.\nNote: In python2, the items() method used to return a list of tuples, and the iteritems() used to do what items() does now in python3.\n12. Construct a dictionary from 2 iterables Use the zip() method to pack 2 iterables into a zip object, then use the dict() method to make that into a dictionary.\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] colors = [\u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;] d = dict(zip(langs, colors)) print(d) # prints {\u0026#39;c\u0026#39;: \u0026#39;blue\u0026#39;, \u0026#39;python\u0026#39;: \u0026#39;green\u0026#39;, \u0026#39;java\u0026#39;: \u0026#39;red\u0026#39;} s = dict(enumerate(colors)) print(s) # prints {1: \u0026#39;blue\u0026#39;, 2: \u0026#39;green\u0026#39;, 3: \u0026#39;red\u0026#39;} 13. Populating a dictionary with default data (Counting with dictionary) Use the defaultdict() method imported from collections. When a key is not in the dictionary, it creates a new key that has the default value.\nfrom collections import defaultdict colors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;] d = defaultdict(int) for color in colors: d[color] += 1 print(dict(d)) # prints {\u0026#39;blue\u0026#39;: 1, \u0026#39;green\u0026#39;: 2, \u0026#39;red\u0026#39;: 3} Note: This is a faster approach than setdefault() on most cases and faster than get() in all cases. Also, defaultdict() seems to work faster on native types like int or string and slower on dict or list. That being said, there are times when you cannot use defaultdict() and have to use either setdefault() or get(), for example when the default value of a certain key depends on the key itself, so defaultdict() cannot be used from the beginning to have a default value for every new key.\ncolors = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;] d = {} for color in colors: d[color] = d.setdefault(color, 2 if color == \u0026#39;red\u0026#39; else 0) + 1 print(d) # prints {\u0026#39;blue\u0026#39;: 1, \u0026#39;green\u0026#39;: 2, \u0026#39;red\u0026#39;: 5} Note 2: A case where get() accomplishes nicely what setdefault() and defaultdict() would do in a more complicated manner is when you have to return a default value from a dictionary if the key is not in it.\nd = { 1: \u0026#39;Alice\u0026#39;, 2: \u0026#39;Bob\u0026#39;, 3: \u0026#39;Carla\u0026#39; } def hello(id): return f\u0026#39;Hi, {d.get(id, \u0026#34;random person\u0026#34;)}\u0026#39; print(hello(1)) # prints Hi, Alice print(hello(4)) # prints Hi, random person 14. Creating a list with n elements Say you want to create a list with 100 elements of 0. You can just do:\nlst = [0] * 100 print(lst) 15. Ternary operator in Python This:\n#include \u0026lt;stdio.h\u0026gt; int main() { int x; int y = 1; x = (y == 1 ? 1 : 0); printf(\u0026#34;%d\u0026#34;, x); return 0; } can be written like this in python:\ny = 1 x = (1 if y == 1 else 0) print(x) 16. Grouping data with dictionaries Say you want to group the items in a list based on some comparison function, for example len():\nfrom collections import defaultdict names = [\u0026#39;julia\u0026#39;, \u0026#39;mark\u0026#39;, \u0026#39;thomas\u0026#39;, \u0026#39;rachel\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;maria\u0026#39;] d = defaultdict(list) for name in names: key = len(name) d[key].append(name) print(dict(d)) # prints {5: [\u0026#39;julia\u0026#39;, \u0026#39;maria\u0026#39;], 4: [\u0026#39;mark\u0026#39;, \u0026#39;alex\u0026#39;], 6: [\u0026#39;thomas\u0026#39;, \u0026#39;rachel\u0026#39;]} All you have to do to group based on some other function is change the key to something else.\n17. Unpacking sequences p = \u0026#39;alex\u0026#39;, \u0026#39;blue\u0026#39;, 20, \u0026#39;c\u0026#39; # same as p = (\u0026#39;alex\u0026#39;, \u0026#39;blue\u0026#39;, 20, \u0026#39;c\u0026#39;) name, color, age, lang = p print(p) # prints a tuple - (\u0026#39;alex\u0026#39;, \u0026#39;blue\u0026#39;, 20, \u0026#39;c\u0026#39;) print(name, color, age, lang) # prints alex blue 20 c Note: In the same manner, swapping 2 variables in python might be the most elegant way out of all the languages:\nx, y = 1, 2 # swap x and y x, y = y, x print(x, y) # prints 2 1 18. Concatenating strings Use the join() method to concatenate strings from an iterable.\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] # join the strings from langs, having \u0026#39;, \u0026#39; as separator text = \u0026#39;, \u0026#39;.join(langs) print(text) # prints c, python, java, c++, kotlin, rust 19. Atomicity of builtin data types Most (!not all) of the builtin data types methods are implemented using C function calls, so that makes it atomic.\nFor a better explanaton check here.\nAlso, dictionaries\u0026rsquo; popitem() is atomic, while pop() may not, based on the key type (if the key is not a builtin data type, Python has to call that object\u0026rsquo;s __hash__() implementation), so better use popitem() where atomicity is needed.\nd = { \u0026#39;foo\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;bar\u0026#39;: \u0026#39;java\u0026#39;, \u0026#39;baz\u0026#39;: \u0026#39;rust\u0026#39; } while d: key, value = d.popitem() print(f\u0026#39;{key} --\u0026gt; {value}\u0026#39;) # prints # foo --\u0026gt; c # bar --\u0026gt; java # baz --\u0026gt; rust # d is empty at the end Note: If unsure, don\u0026rsquo;t hesitate to use mutexes!\n20. Linking and overriding dictionaries with defaults When you have a dictionary that has some default values and you want to override it with another dictionary, use ChainMap(). ChainMap() has the advantage that it doesn\u0026rsquo;t copy anything, it just \u0026ldquo;links\u0026rdquo; the dictionaries, using the initial memory (this also means that any change in the initial dictionary will be reflected in the ChainMap() as well).\nfrom collections import ChainMap defaults = { \u0026#39;bar\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;foo\u0026#39;: \u0026#39;java\u0026#39; } overwritten = { \u0026#39;foo\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;barn\u0026#39;: \u0026#39;c++\u0026#39; } d = ChainMap(overwritten, defaults) print(dict(d)) # prints {\u0026#39;foo\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;barn\u0026#39;: \u0026#39;c++\u0026#39;, \u0026#39;bar\u0026#39;: \u0026#39;c\u0026#39;} Note: Don\u0026rsquo;t use copy() and then update(), it is really bad performance-wise and can be replaced in 99% of the cases by a ChainMap().\nd1 = { \u0026#39;bar\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;foo\u0026#39;: \u0026#39;java\u0026#39; } d2 = { \u0026#39;foo\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;barn\u0026#39;: \u0026#39;c++\u0026#39; } # Don\u0026#39;t do this!! d = d1.copy() d.update(d2) Note 2: For a better example when this is useful, see this.\n21. Ordered dictionary A dictionary is not guaranteed to preserve the order of insertion. It actually optimizes keys for faster lookup. However there is one way to have a dictionary preserve insertion order, using OrderedDict() from collections.\nfrom collections import OrderedDict d = OrderedDict() d[\u0026#39;bar\u0026#39;] = \u0026#39;c\u0026#39; d[\u0026#39;foo\u0026#39;] = \u0026#39;java\u0026#39; d[\u0026#39;baz\u0026#39;] = \u0026#39;rust\u0026#39; print(dict(d)) # prints {\u0026#39;bar\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;foo\u0026#39;: \u0026#39;java\u0026#39;, \u0026#39;baz\u0026#39;: \u0026#39;rust\u0026#39;} Note: Since Python 3.7, regular dicts have guaranteed ordering. More here. Note however that they don\u0026rsquo;t completely replace OrderedDicts, since they have extra features:\nfrom collections import OrderedDict a = {1: 1, 2: 2} b = {2: 2, 1: 1} c = OrderedDict(a) d = OrderedDict(b) print(a == b) # returns True print(c == d) # returns False since OrderedDicts are order-sensitive, and regular dicts are not Also, OrderedDicts have methods to change order of elements, while regular dicts don\u0026rsquo;t.\n22. Using deque instead of a list when updating Deques (double ended queues) are really fast in python3. They are implemented using doubly-linked lists, so inserting and removing at the end or at the beginning is O(1) complexity. Lists are implemented as normal arrays, so they have to sometimes realloc() to accomodate for the number of elements (only sometimes because by default it realloc()s more memory at the time than necessary\u0026rsquo;), so that makes them have O(n) complexity when inserting or removing at the beginning because they have to copy the rest of the elements.\nGenerally, updating a sequence is MUCH faster when using a deque() as opposed to using a list() (though keep in mind that accessing a random element in a deque() is expensive, whereas accessing a random element in a list() is O(1)).\nfrom collections import deque # Wrong! langs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] del langs[0] langs.pop(0) langs.insert(0, \u0026#39;scala\u0026#39;) # Right! langs = deque([\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;]) del langs[0] langs.popleft(0) langs.appendleft(0, \u0026#39;scala\u0026#39;) 23. Temporary contexts Usually there is the case that code like this is written in other languages:\nfrom decimal import getcontext, setcontext old_context = getcontext().copy() getcontext().prec = 50 print(Decimal(355) / Decimal(113)) setcontext(old_context) This can easily be replaced with contexts:\nfrom decimal import localcontext, Context with localcontext(Context(prec=50)): print(Decimal(355) / Decimal(113)) Other examples:\nWriting or reading from file f = open(\u0026#39;data.txt\u0026#39;) try: data = f.read() # do something with data finally: f.close() can be replaced with:\nwith open(\u0026#39;data.txt\u0026#39;) as f: data = f.read() # do something with data Deleting a file (getting rid of the try-except-pass idiom): try: os.remove(\u0026#39;sometempfile.tmp\u0026#39;) except OSError: pass can be replaced with:\nfrom contextlib import suppress with suppress(FileNotFoundError): os.remove(\u0026#39;sometempfile.tmp\u0026#39;) Note: suppress() is a reentrant context manager. More info here.\nUsing a lock lock = threading.Lock() lock.acquire() try: # critical section finally: lock.release() can be replaced with:\nlock = threading.Lock() with lock: # critical section Note: For reentrant lock context manager, see threading.RLock.\nRedirecting output from stdout to file with open(\u0026#39;help.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: sldstdout = sys.stdout sys.stdout = f try: help(pow) finally: sys.stdout = oldstdout can be replaced with:\nwith open(\u0026#39;help.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: with redirect_stdout(f): help(pow) Note: redirect_stdout() is also a reentrant context manager.\nMore on context managers here.\n24. Using the cache for optimized function calls For example, looking up a webpage numerous times is expensive, and usually the result is the same. So use the lru_cache() decorator:\nfrom functools import lru_cache @lru_cache def web_lookup(url): return urllib.urlopen(url).read() More can be found here.\n25. Test a sequence or generator for truthness Using the any() function, you can check if at least one value in the iterable is True. It applies the bool() function to every element.\nfalse_lst = [0, False, \u0026#39;\u0026#39;, 0.0, [], {}, None] # all of these return False when using bool() on them print(any(false_lst)) # prints False true_lst = [1, True, \u0026#39;x\u0026#39;, 3.14, [\u0026#39;x\u0026#39;], {\u0026#39;a\u0026#39;: \u0026#39;b\u0026#39;}] # all of these return True when using bool() on them print(any(true_lst)) # prints True falst_lst.append(-1) # any integer different from 0 is considered True print(any(false_lst)) # prints True Note: This function shortcircuits, meaning the first time it finds True it returns; it does NOT check for the rest of the values to be True.\nNote 2: It is really useful with generators:\nprint(any(range(1000000)) # prints True after 2 values evaluated, as range() is a generator print(any([range(1000000)])) # prints True after the whole list of 1000000 elements has been initialized, as range() has to populate the list first There is another function, all(), that does what it says: it tests for all the elements in the sequence to be True, and works much in the same way as any().\n26. Use namedtuples instead of tuples Aside from the fact that namedtuple()s are more verbose, they also offer better usage, as they can be treated as regular tuples, classes or even dictionaries.\nFor example, having a point:\npt1 = (2, 3) print(pt1[0], pt1[1]) # prints 2 3 can be replaced with the better alternative namedtuple():\nfrom collections import namedtuple Point = namedtuple(\u0026#39;Point\u0026#39;, \u0026#39;x y\u0026#39;) # a tuple named \u0026#39;Point\u0026#39; with attributes \u0026#39;x\u0026#39; and \u0026#39;y\u0026#39; # alternatively this means the exact same thing # Point = namedtuple(\u0026#39;Point\u0026#39;, [\u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;]) pt1 = Point(2, 3) print(pt1) # prints Point(x=2, y=3) print(pt1.x, pt1.y) # prints 2 3 print(pt1[0], pt1[1]) # prints 2 3 print(dict(pt1._asdict())) # prints {\u0026#39;x\u0026#39;: 2, \u0026#39;y\u0026#39;: 3} print(pt1._replace(x=50)) # prints Point(x=50, y=3) # Note however that _replace() returns a modified copy. The original is still a tuple, so it cannot be modified Another common example:\nfrom collections import namedtuple Person = namedtuple(\u0026#39;Person\u0026#39;, \u0026#39;age color lang\u0026#39;) person = Person(31, \u0026#39;blue\u0026#39;, \u0026#39;c\u0026#39;) print(person) # prints Person(age=31, color=\u0026#39;blue\u0026#39;, lang=\u0026#39;c\u0026#39;) Note: When the values from a namedtuple() are invalid (e.g. having one of the fields named class or having the same field twice), it throws a ValueError. To avoid this you can possibly provide a third parameter named rename. If set to True, it will rename the field that is incorrect.\nfrom collections import namedtuple Person = namedtuple(\u0026#39;Person\u0026#39;, \u0026#39;age color age\u0026#39;, rename=True) print(Person(31, \u0026#39;blue\u0026#39;, \u0026#39;whatever\u0026#39;)) # prints Person(age=31, color=\u0026#39;blue\u0026#39;, _2=\u0026#39;whatever\u0026#39;) Note 2: Since Python 3.8, _asdict() method returns a regular dictionary, as regular dicts now have guaranteed ordering based on insertion (since Python 3.7).\n27. Profiling code with cProfile Since Python 3.8, cProfile can be used as a context manager, making it extremely easy to profile code.\nimport cProfile with cProfile.Profile() as profiler: # code to be profiled profiler.print_stats() 28. Pretty print stuff One way to format the output is to use the pprint module.\nfrom pprint import pprint d = { \u0026#39;b\u0026#39;: [*range(5)], \u0026#39;c\u0026#39;: [] \u0026#39;a\u0026#39;: \u0026#34;Here is a long string\u0026#34;.split(\u0026#34; \u0026#34;), } pprint(d, indent=2, width=20, compact=True) # prints # { \u0026#39;a\u0026#39;: [ \u0026#39;Here\u0026#39;, # \u0026#39;is\u0026#39;, \u0026#39;a\u0026#39;, # \u0026#39;long\u0026#39;, # \u0026#39;string\u0026#39;], # \u0026#39;b\u0026#39;: [ 0, 1, 2, 3, # 4], # \u0026#39;c\u0026#39;: []} Note: Since Python 3.8, the parameter sort_dicts was added (True by default):\nfrom pprint import pprint d = { \u0026#39;b\u0026#39;: [*range(5)], \u0026#39;c\u0026#39;: [] \u0026#39;a\u0026#39;: \u0026#34;Here is a long string\u0026#34;.split(\u0026#34; \u0026#34;), } pprint(d, indent=2, width=20, compact=True, sort_dicts=False) # prints # { \u0026#39;b\u0026#39;: [ 0, 1, 2, 3, # 4], # \u0026#39;c\u0026#39;: [], # \u0026#39;a\u0026#39;: [ \u0026#39;Here\u0026#39;, # \u0026#39;is\u0026#39;, \u0026#39;a\u0026#39;, # \u0026#39;long\u0026#39;, # \u0026#39;string\u0026#39;]} More info here.\n29. The \u0026ldquo;is\u0026rdquo; operator vs \u0026ldquo;==\u0026rdquo; operator The is operator checks if 2 objects point to the same memory address. The equality operator == checks if 2 objects are equal.\nlangs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] copy = langs # now copy and langs point to the same memory object print(copy == langs) # prints True print(copy is langs) # prints True other_copy = list(langs) # other_copy has a copy of langs, but point to different memory objects print(other_copy == langs) # prints True print(other_copy is langs) # prints False 30. List slices You can use slices to replace elements, delete elements or make a copy of a list.\nDelete items: langs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] del langs[0:3] print(langs) # prints [\u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] Replace elements of a list without creating a new list object langs = [\u0026#39;c\u0026#39;, \u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;, \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] copy = langs print(copy is langs) # prints True langs[:] = [41, 42, 43] print(copy is langs) # prints True print(copy) # prints [41, 42, 43] langs = [1, 2, 3] print(copy is langs) # prints False, langs points to new list (new memory object) Make a (shallow) copy of a list langs = [\u0026#39;c\u0026#39;, [\u0026#39;python\u0026#39;, \u0026#39;java\u0026#39;], \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] copy = langs[:] copy[1][0] = \u0026#39;some other lang\u0026#39; print(langs) # prints [\u0026#39;c\u0026#39;, [\u0026#39;some other lang\u0026#39;, \u0026#39;java\u0026#39;], \u0026#39;c++\u0026#39;, \u0026#39;kotlin\u0026#39;, \u0026#39;rust\u0026#39;] Note: If you need a deep copy consider using the function deepcopy() from the module copy.\n31. Deep and shallow copies There are 2 types of copies in Python. One is the shallow copy, that works very similar to how assigning to pointers works in C (they only reference the object they point to, changing one also changes the other), and the other is the deep copy, which makes a perfect copy of the object.\nimport copy list1 = [1, 2, [3, 4], 5] list2 = copy.copy(list1) list2[2][1] = 6 list2[0] = 7 # shallow copy, list2 holds references to objects in list1, changing one also changes the other print(list1) # prints [1, 2, [3, 6], 5] print(list2) # prints [7, 2, [3, 6], 5] list3 = copy.deepcopy(list1) list3[2][1] = 8 list3[0] = 9 # deep copy, list3 is a perfect copy of list1 with no references to it, changing one doesn\u0026#39;t change the other print(list1) # prints [1, 2, [3, 6], 5] print(list3) # prints [9, 2, [3, 8], 5] More about deep and shallow copies here.\n32. Python\u0026rsquo;s built-in http server Python has a built-in http server; it can be super useful if you want to preview a website without going the hurdle of starting an apache or nginx server.\nThis serves the website in the current directory at address localhost:8000:\npython3 -m http.server 33. Type annotations Python 3.5 supports type annotations, which can ensure better readability. Note however that they are only there for the programmer to acknowledge, Python does not care and won\u0026rsquo;t change anything based on them.\ndef func(s1: int, s2: int = 42) -\u0026gt; int: return s1 + s2 They can be changed to anything you want:\ndef func2(page: \u0026#39;web page\u0026#39;, request: \u0026#39;web request\u0026#39;) -\u0026gt; \u0026#39;web response\u0026#39;: # return response Note: Passing 2 strings to func() is perfectly valid, as Python does NOT care at all about these annotations (in this case the function would return the 2 strings concatenated).\nNote 2: You can use stuff like Mypy to enforce this kind of behaviour, so Python becomes statically-typed!\nMore info about type annotations can be found in PEP 484.\nNote 3: Since Python 3.6, PEP 526, more support for type annotations was added. Again, Python will always be a dynamically-typed language, but tools can be used to ensure static typing.\n34. Counter for iterables This is an easy method to find the most common elements in an iterable:\nimport collections count = collections.Counter(\u0026#39;some random string\u0026#39;) print(c.most_common()) # prints [(\u0026#39;s\u0026#39;, 2), (\u0026#39;o\u0026#39;, 2), (\u0026#39;m\u0026#39;, 2), (\u0026#39; \u0026#39;, 2), (\u0026#39;r\u0026#39;, 2), (\u0026#39;n\u0026#39;, 2), (\u0026#39;e\u0026#39;, 1), (\u0026#39;a\u0026#39;, 1), (\u0026#39;d\u0026#39;, 1), (\u0026#39;t\u0026#39;, 1), (\u0026#39;i\u0026#39;, 1), (\u0026#39;g\u0026#39;, 1)] print(c.most_common(3)) # prints [(\u0026#39;s\u0026#39;, 2), (\u0026#39;o\u0026#39;, 2), (\u0026#39;m\u0026#39;, 2)] More info can be found in the Python docs for the Counter class.\n35. Permutations of an iterable Get permutations of an iterable:\nimport itertools lst = list(itertools.permutations(\u0026#39;abc\u0026#39;, 2)) print(lst) # prints [(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;), (\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;), (\u0026#39;c\u0026#39;, \u0026#39;a\u0026#39;), (\u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;)] The function takes an iterable and another optional argument specifying the length of one permutation.\n36. Getting the representation of an object as a string Python has 2 methods to transform an object into a string (similar to other languages toString() methods); those are str() and repr().\nimport datetime now = datetime.date.today() print(str(now)) # prints \u0026#39;2020-02-12\u0026#39; print(repr(now)) # prints \u0026#39;datetime.date(2020, 2, 12)\u0026#39; The function str() is made for clarity, while the function repr() is made to be unambiguos about what the object represents.\nThe python console uses repr().\n37. Python disassembler Python has a built-in disassembler. It is very rudimentary, but it can help debug some code.\nimport dis def func(text): return \u0026#39;This is some text \\\u0026#39;\u0026#39; + str(text) + \u0026#39;\\\u0026#39;.\u0026#39; dis.dis(func) # 4 0 LOAD_CONST 1 (\u0026#34;This is some text \u0026#39;\u0026#34;) # 2 LOAD_GLOBAL 0 (str) # 4 LOAD_FAST 0 (text) # 6 CALL_FUNCTION 1 # 8 BINARY_ADD # 10 LOAD_CONST 2 (\u0026#34;\u0026#39;.\u0026#34;) # 12 BINARY_ADD # 14 RETURN_VALUE More info in the docs.\n38. Lambda functions Lambda functions, as in other functional programming languages, are anonymous functions that don\u0026rsquo;t have a name. They are useful for small code that doesn\u0026rsquo;t require more than a line or two, and they are generally passed as arguments to other functions.\nOne such example that applies to all functional programming languages is the map() function. It takes a callable as the first argument (read function, lambda function, something that can be called), and an iterable as the second argument, and applies the function to each of the elements of the iterable, returning a new iterable.\nobj = map(lambda string: string.lower(), [\u0026#39;StRiNg\u0026#39;, \u0026#39;ANOTHER string\u0026#39;]) print(list(obj)) # prints [\u0026#39;string\u0026#39;, \u0026#39;another string\u0026#39;] This code does the exact same thing:\ndef stringlower(string): return string.lower() lst = [\u0026#39;StRiNg\u0026#39;, \u0026#39;ANOTHER string\u0026#39;] obj = [] for item in lst: obj.append(stringlower(item)) print(obj) # prints [\u0026#39;string\u0026#39;, \u0026#39;another string\u0026#39;] Another example:\npower_func = lambda x, y: x ** y print(power_func(2, 3)) # prints 8 x = (lambda a, b: a - b)(5, 4) print(x) # prints 1 39. Ip addresses in Python Python has an interesting module to work with Ip addresses:\nimport ipaddress address = ipaddress.ip_address(\u0026#39;192.168.100.14\u0026#39;) print(repr(address)) # prints IPv4Address(\u0026#39;192.168.100.14\u0026#39;) # you can even have arithmetic operations done on this address print(address + 3) # prints 192.168.100.17 More info here.\n40. Subclasses and subinstances In Python, you can check if a class is a subclass of some other class:\nclass BaseClass(): pass class SubClass(BaseClass): pass print(issubclass(SubClass, BaseClass)) # prints True print(issubclass(SubClass, object)) # prints True You can also check if some instance is an instance of the specified class or another sublass of that class:\nclass BaseClass(): pass class SubClass(BaseClass): pass obj = SubClass() print(isinstance(obj, BaseClass)) # prints True 41. Asterisk (*) and slash (\\) in function definition (positional- and keyword-only function parameters) In Python 3, you can add an asterisk and a slash to a function definition with special meaning. Asterisk marks keyword-only parameters (that means parameters that can be given to the function just by keyword, not by position), while slash marks positional-only parameters (meaning parameters cannot be given by keyword, but by position only).\ndef func(positional_only_argument, /, positional_and_keyword_argument, *, keyword_only_argument): return positional_only_argument + positional_and_keyword_argument + keyword_only_argument print(func(1, 2, 3)) # Type error, third parameter should be keyword print(func(positional_only_argument = 1, 2, 3)) # Type error, first parameter is positional only print(func(1, 2, keyword_only_argument = 3)) # fine, prints 6 print(func(1, positional_and_keyword_argument = 2, keyword_only_argument = 3)) # fine, prints 6 Info and rationale about these 2 types of parameters can be found in PEP 3102 - keyword-only parameters and in PEP 570 - positional-only parameters.\nNote: Until Python 3.8, positional-only arguments could only be used in library functions. Starting from Python 3.8, they can be used in programmer constructions too.\n42. Python interactive shell Say you wrote some Python code like this:\ndef min(a, b): return a if a \u0026lt; b else b You can launch it in an interactive shell with python -i main.py, which is similar to calling only python in the command line, with the key difference that the python shell contains your function in the global scope as well. Go ahead, try it!\n43. Python debugger Python has a debugger, similar to gdb. One way to use it is to simply add import pdb; pdb.set_trace() in your program wherever u want the debugger to stop program execution.\nIn Python 3.7, the debugger can also be called on a script like this: python -m pdb script.py, and it stops when the module loads, just before executing the first line of the script.\ndef add(a, b): return a + b import pdb pdb.set_trace() # code execution will stop here, and the program will enter the debugger print(add(1, 2)) For more information on how to operate the python debugger, visit this.\nNote: Since Python 3.7, instead of import pdb; pdb.set_trace(), you can simply add a breakpoint() function call whenever you want the program to stop execution.\n44. The walrus operator (:=) Python 3.8 introduced assignment expressions through the use of a new operator, called the walrus operator (if you look sideways, the operator looks like a walrus).\nAssignment expressions allow you to assign and return a value in the same expression, similar to how things work in a language like C.\nwhile (x := int(input(\u0026#34;What is your age?\u0026#34;))) \u0026gt; 18: print(\u0026#34;You are a grown-up!\u0026#34;) else: print(\u0026#34;You are a kid!\u0026#34;) It can be useful, for example in list comprehensions:\nlst = [y for x in \u0026#39;abcd\u0026#39; if (y := f(x)) is not None] # instead of having to compute f(x) twice lst = [f(x) for x in \u0026#39;abcd\u0026#39; if f(x) is not None] Arguably, the operator is a little confusing, and most of the times not needed and can be replaced with more expressive syntax. There are good arguments to why this operator is not needed in Python here.\nNonetheless, Python 3.8 adopted assignment expressions through the use of the walrus operator :=.\nFor more info on the walrus operator and assignment expressions, see PEP 572.\n45. Formatted strings (f-strings) Formatted string literals (or f-strings) are a construct added in Python 3.6 and have since become very popular due to the speed (see tip 7) and simplicity.\nSome examples:\nnumber = 3.1415 width = 10 precision = 3 print(f\u0026#39;This is {number:{width}.{precision}}\u0026#39;) # prints # This is 3.14 There are three conversion fields; r, s and a. What they do is call the functions repr(), str() and ascii() respectively on the formatted parameter.\nname = \u0026#39;Alex\u0026#39; print(f\u0026#39;My name is {name!r}\u0026#39;) # prints # My name is \u0026#39;Alex\u0026#39; Since Python 3.8, there is a new specifier (=), that expands to the representation of the expression, making it useful for debugging and self-documenting.\nimport datetime name = \u0026#39;Alex\u0026#39; print(f\u0026#39;{name=}\u0026#39;) # prints name=\u0026#39;Alex\u0026#39; now = datetime.date.today() print(f\u0026#39;{now=}\u0026#39;) # prints now=datetime.date(2020, 2, 14) # f-string specifiers still work print(f\u0026#39;{now=!s}\u0026#39;) # prints now=2020-02-14 number = 3.1415 # Careful when adding format specifiers print(f\u0026#39;{number + 1=:10.2f}\u0026#39;) # prints number + 1= 4.14 print(f\u0026#39;{number + 1=:10.2}\u0026#39;) # prints number + 1= 4.1 More info about f-strings in the docs.\nNote: Formatted strings have a \u0026lsquo;formatting\u0026rsquo; option similar to how printf() works in other languages. Python\u0026rsquo;s implementation of formatted print is a little more advanced though.\n46. Decorators and the functools.wraps helper function Say you have a function:\ndef sum(a, b): \u0026#34;\u0026#34;\u0026#34;This function adds 2 numbers and returns the result.\u0026#34;\u0026#34;\u0026#34; return a + b But now we want to log this function call. Of course, adding this code in the implementation of the function is bad, since we\u0026rsquo;re polluting the function code. Even more so, what if we want to log another 10 function calls?\nFor this purpose, we can easily use a decorator.\ndef log(func): def wrapper(*args, **kwargs): \u0026#34;\u0026#34;\u0026#34;Wrapper function.\u0026#34;\u0026#34;\u0026#34; # do some logging return func(*args, **kwargs) return wrapper Now it is easy to use the decorator on whatever function we want to log.\n@log def sum(a, b): \u0026#34;\u0026#34;\u0026#34;This function adds 2 numbers and returns the result.\u0026#34;\u0026#34;\u0026#34; return a + b print(sum(4, 5)) # this function call will be logged However, one problem arises when decorating a function like this. If we now try to get the doc or the function name, we notice that we get the information of the wrapper function, rather than that of our initial function:\nprint(sum.__doc__) # prints \u0026#34;Wrapper function\u0026#34; print(sum.__name__) # prints \u0026#34;wrapper\u0026#34; This is not ideal, considering that debuggers and other introspection tools use this. To fix this, we can use functools.wraps.\nimport functools def log(func): @functools.wraps(func) def wrapper(*args, **kwargs): \u0026#34;\u0026#34;\u0026#34;Wrapper function.\u0026#34;\u0026#34;\u0026#34; # do some logging return func(*args, **kwargs) return wrapper @log def sum(a, b): \u0026#34;\u0026#34;\u0026#34;This function adds 2 numbers and returns the result.\u0026#34;\u0026#34;\u0026#34; return a + b print(sum.__doc__) # prints \u0026#34;This function adds 2 numbers and returns the result.\u0026#34; print(sum.__name__) # prints \u0026#34;sum\u0026#34; 47. Static function variables Python does not have a built-in method to have a static variable in a function like C or other languages do through the use of the static keyword.\nInstead, we can use the fact that functions are first-class objects in Python and we can assign variables to them.\ndef func(): try: func.number_of_times_called += 1 except: func.number_of_times_called = 1 # some really interesting code This is better than having a global variable pollute the global namespace, and is better than having a decorator that does that (because the decorator runs when the python module is loaded even if the function might never be called, so the decorator will still do some work and initialize some value; instead here the code runs only when the function is called, if ever).\n","permalink":"https://shenlong616.github.io/posts/github/python-3-tricks-by-alexghergh/","summary":"Python 3 tricks Disclaimer: This list is meant as a comprehension of cool tips and tricks I found on the internet. If you would like to contribute, or notice any mistakes or typos, please contact me or upload a pull request. If you think any material here can be considered personal property let me know and I will take it down.\n1. Looping over a range of numbers Using range() is better than using a list (ex.","title":"Python 3 tricks by alexghergh"},{"content":"A collection of JavaScript tips and tricks.\nNo particular order or path.\nI add things as I discover them.\nCheck Codinghub.tips, too, for JavaScript tips. It\u0026rsquo;s not my project but I like it. üî•\nOPTIONAL CHAINING \u0026ldquo;Shorter and simpler expressions when accessing chained properties when the possibility exists that a reference may be missing.\u0026rdquo; (Source: MDN)\nconst person = { name: \u0026#34;Catalin Pit\u0026#34;, socialMedia: { twitter: \u0026#34;@catalinmpit\u0026#34;, instagram: \u0026#34;@catalinmpit\u0026#34;, linkedin: \u0026#34;@catalinmpit\u0026#34;, }, experience: \u0026#34;Junior\u0026#34;, employed: true, }; if (person \u0026amp;\u0026amp; person.socialMedia \u0026amp;\u0026amp; person.socialMedia.twitter) { console.log(person.socialMedia.twitter); } // The same thing with optional chaining if (person?.socialMedia?.twitter) { console.log(person.socialMedia.twitter); // outputs @catalinmpit } // or console.log(person?.socialMedia?.twitter); NULLISH COALESCING OPERATOR \u0026ldquo;The nullish coalescing operator (??) is a logical operator that returns its right-hand side operand when its left-hand side operand is null or undefined, and otherwise returns its left-hand side operand.\u0026rdquo; (Source: MDN)\nconst person = { name: \u0026#34;Catalin Pit\u0026#34;, socialMedia: { twitter: \u0026#34;@catalinmpit\u0026#34;, instagram: \u0026#34;@catalinmpit\u0026#34;, linkedin: \u0026#34;@catalinmpit\u0026#34;, }, experience: \u0026#34;Junior\u0026#34;, employed: true, }; console.log(person.socialMedia.facebook ?? \u0026#34;No Facebook account found!\u0026#34;); // Outputs \u0026#39;No Facebook account found!\u0026#39; console.log(person.socialMedia.instagram ?? \u0026#34;No Instagram account found!\u0026#34;); // Outputs \u0026#39;@catalinmpit\u0026#39; /// Another example /// let name; console.log(name ?? \u0026#34;No name assigned\u0026#34;); // Outputs \u0026#39;No name assigned\u0026#39; let name = \u0026#34;Catalin Pit\u0026#34;; console.log(name ?? \u0026#34;No name assigned\u0026#34;); // Outputs \u0026#39;Catalin Pit\u0026#39; MERGE OBJECTS TOGETHER - SPREAD OPERATOR \u0026ldquo;Shallow-cloning (excluding prototype) or merging of objects is now possible using a shorter syntax than Object.assign().\u0026rdquo; (Source: MDN)\nconst user = { name: \u0026#34;Catalin Pit\u0026#34;, role: \u0026#34;Junior Fullstack Developer\u0026#34;, age: 23, }; const uses = { machine: \u0026#34;MacBook Pro 15 inch\u0026#34;, editor: \u0026#34;VS Code\u0026#34;, language: \u0026#34;JavaScript\u0026#34;, phone: \u0026#34;Samsung Note 10\u0026#34;, }; const summary = { ...user, ...uses }; console.log(summary); // Outputs // const summary = { name: \u0026#34;Catalin Pit\u0026#34;, role: \u0026#34;Junior Fullstack Developer\u0026#34;, age: 23, machine: \u0026#34;MacBook Pro 15 inch\u0026#34;, editor: \u0026#34;VS Code\u0026#34;, language: \u0026#34;JavaScript\u0026#34;, phone: \u0026#34;Samsung Note 10\u0026#34;, }; TWO WAYS TO CONVERT A STRING TO A CHARACTER ARRAY These are two quick ways to convert your string to an array of characters.\nconst firstName = \u0026#34;Catalin\u0026#34;; const firstNameArr1 = firstName.split(\u0026#34;\u0026#34;); console.log(firstNameArr1); const firstNameArr2 = [...firstName]; console.log(firstNameArr2); DEFAULT PARAMETERS \u0026ldquo;Default function parameters allow named parameters to be initialized with default values if no value or undefined is passed.\u0026rdquo; (Source: MDN)\nfunction add(x = 1, y = 2) { return x + y; } add(); // Returns 3 add(10); // Returns 12 add(5, 5); // Returns 10 FILTER UNIQUE VALUES / REMOVE DUPLICATE VALUES \u0026ldquo;Set objects are collections of values. You can iterate through the elements of a set in insertion order. A value in the Set may only occur once; it is unique in the Set\u0026rsquo;s collection.\u0026rdquo; (Source: MDN)\n// Strings const names = [ \u0026#34;Catalin\u0026#34;, \u0026#34;Catalin\u0026#34;, \u0026#34;Pit\u0026#34;, \u0026#34;Pit\u0026#34;, \u0026#34;Tom\u0026#34;, \u0026#34;Tom\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;John\u0026#34;, ]; const uniqueNames = [...new Set(names)]; console.log(uniqueNames); // Outputs [\u0026#39;Catalin\u0026#39;, \u0026#39;Pit\u0026#39;, \u0026#39;Tom\u0026#39;, \u0026#39;John\u0026#39;] // Numbers const examScores = [ 50, 75, 100, 99, 95, 67, 43, 43, 43, 100, 99, 50, 50, 50, 50, ]; const uniqueExamScores = [...new Set(examScores)]; console.log(uniqueExamScores); // Outputs [50, 75, 100, 99, 95, 67, 43]; FILTER OUT FALSY VALUES Remove falsy values such as null, undefined, 0, boolean and so on, from an array.\nconst myArray = [ \u0026#34;Catalin\u0026#34;, 1, \u0026#34;Macbook\u0026#34;, false, true, \u0026#34;Car\u0026#34;, \u0026#34;Peace\u0026#34;, 191, false, ]; const filteredArray = myArray.filter(Boolean); console.log(filteredArray); // Returns [\u0026#34;Catalin\u0026#34;, 1, \u0026#34;Macbook\u0026#34;, true, \u0026#34;Car\u0026#34;, \u0026#34;Peace\u0026#34;, 191] REQUIRED PARAMETERS Default parameters allows us to require an argument to be passed to the function.\nWe can create a function which throws an error and assign it as default value for required parameters.\nconst required = () =\u0026gt; { throw new TypeError(\u0026#34;You did not pass the required argument!\u0026#34;); }; const greet = (name = required()) =\u0026gt; console.log(`Hello ${name}!`); greet(); // Returns \u0026#34;Uncaught TypeError: You did not pass the required argument!\u0026#34; greet(\u0026#34;Catalin Pit\u0026#34;); // Returns \u0026#34;Hello Catalin Pit!\u0026#34; PASS AN EMPTY PARAMETER With the help of the spread syntax, we can now pass an empty parameter to a function.\n\u0026ldquo;Spread syntax allows an iterable such as an array expression or string to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected, or an object expression to be expanded in places where zero or more key-value pairs (for object literals) are expected.\u0026rdquo; (Source: MDN)\nfunction greet(fullName, instagramHandle, twitterHandle) { let message = `Hello, my name is ${fullName}.`; if (instagramHandle) { message += ` My Instagram handle is ${instagramHandle}.`; } if (twitterHandle) { message += ` My Twitter handle is ${twitterHandle}.`; } return message; } // Returns \u0026#34;Hello, my name is Catalin Pit.\u0026#34; console.log(greet(\u0026#34;Catalin Pit\u0026#34;)); // Returns \u0026#34;Hello, my name is Catalin Pit. My Instagram handle is @cpit. My Twitter handle is @catapit.\u0026#34; console.log(greet(\u0026#34;Catalin Pit\u0026#34;, \u0026#34;@cpit\u0026#34;, \u0026#34;@catapit\u0026#34;)); // Returns \u0026#34;Hello, my name is Catalin Pit. My Twitter handle is @cpit.\u0026#34; greet(...[\u0026#34;Catalin Pit\u0026#34;, , \u0026#34;@cpit\u0026#34;]); // Returns \u0026#34;Hello, my name is Catalin Pit. My Instagram handle is @catapit.\u0026#34; greet(...[\u0026#34;Catalin Pit\u0026#34;, \u0026#34;@catapit\u0026#34;]); ACCEPT ANY NUMBER OF ARGUMENTS IN A FUNCTION We are making use of the spread operator again to accept any number of arguments in a function.\nfunction accumulator(...args) { let acc = 0; for (let val of args) { acc += val; } return acc; } accumulator(); // Outputs 0 accumulator(5); // Outputs 5 accumulator(1, 5); // Outputs 6 accumulator(5, 9, 3); // Outputs 17 accumulator(1, 9, 2, 8); // Outputs 20 accumulator(8, 1, 9, 2, 1000); // Outputs 1020 CHECK IF EVERY ITEM FROM AN ARRAY PASSES A TEST CONDITION \u0026ldquo;The every() method tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.\u0026rdquo; (Source: MDN)\nlet closeOffice = [\u0026#34;false\u0026#34;, \u0026#34;true\u0026#34;, \u0026#34;false\u0026#34;, \u0026#34;true\u0026#34;]; let closeOffice2 = [\u0026#34;true\u0026#34;, \u0026#34;true\u0026#34;, \u0026#34;true\u0026#34;, \u0026#34;true\u0026#34;]; let closeOffice3 = [\u0026#34;false\u0026#34;, \u0026#34;false\u0026#34;, \u0026#34;false\u0026#34;, \u0026#34;false\u0026#34;]; function doYouWorkFromHome(answer) { return answer == \u0026#34;true\u0026#34;; } closeOffice.every(doYouWorkFromHome); // Returns false - We don\u0026#39;t close the office closeOffice2.every(doYouWorkFromHome); // Returns true - We close the office closeOffice3.every(doYouWorkFromHome); // Returns false - We don\u0026#39;t close the office CHECK IF SOME ITEMS FROM AN ARRAY PASS A TEST CONDITION \u0026ldquo;The some() method tests whether at least one element in the array passes the test implemented by the provided function. It returns a Boolean value.\u0026rdquo; (Source: MDN)\nlet devTeam = [\u0026#34;junior\u0026#34;, \u0026#34;middle\u0026#34;, \u0026#34;middle\u0026#34;, \u0026#34;junior\u0026#34;, \u0026#34;senior\u0026#34;, \u0026#34;senior\u0026#34;]; let devTeam1 = [\u0026#34;junior\u0026#34;, \u0026#34;middle\u0026#34;, \u0026#34;middle\u0026#34;, \u0026#34;junior\u0026#34;, \u0026#34;junior\u0026#34;, \u0026#34;middle\u0026#34;]; let devTeam2 = [\u0026#34;junior\u0026#34;, \u0026#34;middle\u0026#34;, \u0026#34;middle\u0026#34;, \u0026#34;junior\u0026#34;, \u0026#34;senior\u0026#34;, \u0026#34;junior\u0026#34;]; function proceedWithProject(answer) { return answer == \u0026#34;senior\u0026#34;; } devTeam.some(proceedWithProject); // Returns true - We can proceed with the project devTeam1.some(proceedWithProject); // Returns false - We cannot proceed with the project devTeam2.some(proceedWithProject); // Returns true - We can proceed with the project ","permalink":"https://shenlong616.github.io/posts/github/javascript-tips-tricks-by-catalinpit/","summary":"A collection of JavaScript tips and tricks.\nNo particular order or path.\nI add things as I discover them.\nCheck Codinghub.tips, too, for JavaScript tips. It\u0026rsquo;s not my project but I like it. üî•\nOPTIONAL CHAINING \u0026ldquo;Shorter and simpler expressions when accessing chained properties when the possibility exists that a reference may be missing.\u0026rdquo; (Source: MDN)\nconst person = { name: \u0026#34;Catalin Pit\u0026#34;, socialMedia: { twitter: \u0026#34;@catalinmpit\u0026#34;, instagram: \u0026#34;@catalinmpit\u0026#34;, linkedin: \u0026#34;@catalinmpit\u0026#34;, }, experience: \u0026#34;Junior\u0026#34;, employed: true, }; if (person \u0026amp;\u0026amp; person.","title":"JAVASCRIPT TIPS \u0026 TRICKS by catalinpit"}]